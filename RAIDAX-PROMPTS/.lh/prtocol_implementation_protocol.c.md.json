{
    "sourceFile": "prtocol_implementation_protocol.c.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1751889522301,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1751889522301,
            "name": "Commit-0",
            "content": "Language-Agnostic Specification: Protocol Implementation\r\n1. Module Purpose\r\nThis module implements the application-level logic of the RAIDAX protocol. It orchestrates the processing of a client request, from validating the data to invoking the correct command handler and preparing the response. It acts as the bridge between the raw network I/O and the business logic of the command handlers.\r\n\r\n2. Core Components\r\nCommand Dispatcher: A mechanism (e.g., a hash map, a 2D array) to map a command_group and command_id to the specific function that handles that command.\r\n\r\n3. Function Implementations\r\n3.1. run_command(connection_object)\r\nRole: The entry point for processing a fully received request. This function is executed by a worker thread.\r\n\r\nLogic:\r\n\r\nUsing the command_group and command_id from the connection_object, look up the appropriate command handler function.\r\n\r\nIf the handler is not found, prepare an \"Invalid Command\" error response.\r\n\r\nIf found, execute the handler function, passing it the connection_object. The handler is responsible for performing its specific logic and populating the output and output_size fields in the connection_object.\r\n\r\nAfter the handler returns, call prepare_response(connection_object).\r\n\r\n3.2. prepare_response(connection_object)\r\nRole: To serialize the response and prepare the connection for the network layer to handle the writing. This is a critical function that separates business logic from network I/O.\r\n\r\nLogic:\r\n\r\nUDP vs. TCP:\r\n\r\nIf the connection is UDP (determined by checking for a client address object), the response should be built and sent immediately using a sendto-like function. The connection object should then be freed.\r\n\r\nTCP:\r\n\r\nCalculate the total size of the response packet (header + body + trailer).\r\n\r\nAllocate a write_buffer in the connection_object of this size.\r\n\r\nSerialize the response header into the start of the write_buffer.\r\n\r\nIf there is a response body (output_size > 0), perform any necessary encryption on the output data.\r\n\r\nCopy the (potentially encrypted) output data into the write_buffer after the header.\r\n\r\nAppend the two-byte trailer to the end of the write_buffer.\r\n\r\nSet the bytes_to_write and bytes_written fields in the connection_object.\r\n\r\nCrucially, set the connection's state to STATE_WANT_WRITE.\r\n\r\nFinally, call the arm_socket_for_write(connection_object) function. This is the thread-safe signal that notifies the main I/O thread that this connection is now ready to be written to.\r\n\r\n3.3. Error Handling\r\nA centralized function, send_command_error(error_code, connection_object), should be implemented to streamline error handling. It should set the command status, clear any pending output, and then call prepare_response to send the error back to the client.\r\n\r\n3.4. Unchanged Logic\r\nThe internal logic for validating the protocol header (validate_header) and body (validate_decrypt_body), and for serializing the response header (get_response_header), remains conceptually the same, although the implementation will be language-specific."
        }
    ]
}