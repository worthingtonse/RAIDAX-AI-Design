{
    "sourceFile": "locker_command_handler_cmd_locler.c.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1751955397733,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1751959949954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -356,5 +356,376 @@\n 7.3 I/O Optimization\r\n \r\n Queue dirty pages instead of synchronous writes\r\n Batch filesystem operations where possible\r\n-Minimize crypto key file reads\n\\ No newline at end of file\n+Minimize crypto key file reads\r\n+\r\n+\r\n+////////////////////\r\n+\r\n+# Language-Agnostic Specification: Locker Command Handlers\r\n+\r\n+## 1. Module Purpose\r\n+This module implements the business logic for all commands related to coin lockers. These handlers interact with the primary database, validate client requests, and ensure the in-memory Locker Index is kept perfectly in sync with the state of the database.\r\n+\r\n+## 2. Architectural Requirements\r\n+\r\n+### 2.1 Data Flow Order\r\n+- **Primary Data Source**: All state changes must be written to the primary database first\r\n+- **Asynchronous Persistence**: Modified pages must be queued for disk write via add_page_to_dirty_queue()\r\n+- **Index Synchronization**: In-memory index updates occur only after successful database modifications\r\n+\r\n+### 2.2 Transaction Integrity\r\n+- Database modifications must be atomic per command\r\n+- Index updates must match database state exactly\r\n+- Partial failures must not corrupt either database or index\r\n+\r\n+## 3. Common Data Structures\r\n+\r\n+### 3.1 Request/Response Structure\r\n+```\r\n+conn_info_t:\r\n+  - body_size: Integer (total request size)\r\n+  - command_status: Byte (response status code)\r\n+  - output: Byte array (response data)\r\n+  - output_size: Integer (response data length)\r\n+```\r\n+\r\n+### 3.2 Status Codes\r\n+- **STATUS_ALL_PASS**: All operations successful\r\n+- **STATUS_ALL_FAIL**: All operations failed\r\n+- **STATUS_MIXED**: Partial success (batch operations)\r\n+- **STATUS_WAITING**: Operation pending external verification\r\n+- **ERROR_INVALID_PACKET_LENGTH**: Malformed request\r\n+- **ERROR_COINS_NOT_DIV**: Coin data not properly aligned\r\n+- **ERROR_INVALID_SN_OR_DENOMINATION**: Invalid coin identifier\r\n+- **ERROR_INVALID_PAN**: Invalid proposed AN format\r\n+- **ERROR_INVALID_PARAMETER**: General parameter error\r\n+- **ERROR_MEMORY_ALLOC**: Memory allocation failure\r\n+- **ERROR_INTERNAL**: Unexpected internal error\r\n+- **ERROR_TRADE_LOCKER_EXISTS**: Duplicate trade locker\r\n+- **ERROR_TRADE_LOCKER_NOT_FOUND**: Trade locker not found\r\n+- **ERROR_INVALID_TRADE_COIN**: Invalid currency type\r\n+- **ERROR_FILESYSTEM**: File I/O error\r\n+- **ERROR_NO_PRIVATE_KEY**: Missing crypto key\r\n+\r\n+### 3.3 Constants\r\n+- Coin record size: 17 bytes (16 AN + 1 MFS)\r\n+- Standard locker AN suffix: 0xFF 0xFF 0xFF 0xFF\r\n+- Trade locker AN suffix: 0xEE 0xEE\r\n+- Trade type position: AN[13]\r\n+- Price position: AN[9:12] (4 bytes, big-endian)\r\n+\r\n+## 4. Core Command Implementations\r\n+\r\n+### 4.1. cmd_store_sum\r\n+**Purpose**: Creates or adds coins to a standard locker.\r\n+\r\n+**Request Format**:\r\n+```\r\n+[16 bytes CH] [5 bytes per coin (DN + 4 SN)] [16 bytes SU] [16 bytes PN] [2 bytes EOF]\r\n+Minimum size: 55 bytes\r\n+```\r\n+\r\n+**Validation Steps**:\r\n+- Verify request size >= 55 bytes\r\n+- Calculate coin count: (body_size - 50) / 5\r\n+- Verify coin data is divisible by 5\r\n+- Verify PN ends with 0xFF 0xFF 0xFF 0xFF\r\n+\r\n+**Core Logic**:\r\n+1. Allocate array for coins to be added\r\n+2. Calculate XOR sum of current ANs:\r\n+   - For each coin:\r\n+     - Extract denomination (1 byte) and SN (4 bytes)\r\n+     - Lock database page containing coin\r\n+     - XOR the coin's current AN into running sum\r\n+     - Store coin info for later use\r\n+     - Unlock page\r\n+3. Compare calculated XOR with provided SU\r\n+4. If authentic:\r\n+   - For each coin:\r\n+     - Lock database page\r\n+     - Update coin's AN to PN\r\n+     - Set MFS byte\r\n+     - Call add_page_to_dirty_queue(page)\r\n+     - Increment statistics\r\n+     - Unlock page\r\n+5. Call locker_index_add_coins(PN, coins_array, count)\r\n+6. Set status to STATUS_ALL_PASS or STATUS_ALL_FAIL\r\n+\r\n+**Error Handling**:\r\n+- Free allocated memory on any error\r\n+- Return appropriate error code\r\n+- Do not update index if database update fails\r\n+\r\n+### 4.2. cmd_remove\r\n+**Purpose**: Removes specific coins from a standard locker.\r\n+\r\n+**Request Format**:\r\n+```\r\n+[16 bytes CH] [16 bytes AN] [21 bytes per coin (DN + 4 SN + 16 CAN)] [2 bytes EOF]\r\n+Minimum size: 55 bytes\r\n+```\r\n+\r\n+**Validation Steps**:\r\n+- Verify request size >= 55 bytes\r\n+- Calculate coin count: (body_size - 34) / 21\r\n+- Verify coin data is divisible by 21\r\n+\r\n+**Core Logic**:\r\n+1. Call get_coins_from_index(AN) to get locker contents\r\n+2. If locker not found, return STATUS_ALL_FAIL\r\n+3. Allocate output buffer: (coin_count / 8) + 1 bytes for bitmap\r\n+4. For each coin to remove:\r\n+   - Extract DN, SN, and new CAN from request\r\n+   - Verify coin exists in locker (search index entry)\r\n+   - If found:\r\n+     - Lock database page\r\n+     - Update coin's AN to CAN\r\n+     - Set MFS byte\r\n+     - Call add_page_to_dirty_queue(page)\r\n+     - Set success bit in output bitmap\r\n+     - Add to removal list\r\n+     - Unlock page\r\n+   - If not found, increment failure count\r\n+5. Call locker_index_remove_coins(AN, removal_list, removal_count)\r\n+6. Set appropriate status based on success/failure counts\r\n+\r\n+**Response Format**:\r\n+- Bitmap where bit N indicates success (1) or failure (0) for coin N\r\n+\r\n+### 4.3. cmd_peek\r\n+**Purpose**: Retrieves coins in a standard locker (read-only).\r\n+\r\n+**Request Format**:\r\n+```\r\n+[16 bytes CH] [16 bytes AN] [2 bytes EOF]\r\n+Size: exactly 34 bytes\r\n+```\r\n+\r\n+**Core Logic**:\r\n+1. Validate request size == 34\r\n+2. Call get_coins_from_index(AN)\r\n+3. If not found, return STATUS_ALL_FAIL\r\n+4. Allocate output buffer: num_coins * 5 bytes\r\n+5. For each coin in index entry:\r\n+   - Write denomination (1 byte)\r\n+   - Write SN (4 bytes, big-endian)\r\n+6. Set status to STATUS_ALL_PASS\r\n+\r\n+**Response Format**:\r\n+```\r\n+[5 bytes per coin (DN + 4 SN)]\r\n+```\r\n+\r\n+### 4.4. cmd_put_for_sale\r\n+**Purpose**: Creates a trade locker for selling coins.\r\n+\r\n+**Request Format**:\r\n+```\r\n+[16 bytes CH] [5 bytes per coin] [16 bytes SU] [16 bytes PN] \r\n+[1 byte AS] [128 bytes AD] [2 bytes EOF]\r\n+Minimum size: 184 bytes\r\n+```\r\n+\r\n+**Special PN Format**:\r\n+- PN[9:12]: Price (4 bytes, big-endian)\r\n+- PN[13]: Trade currency type\r\n+- PN[14:15]: Must be 0xEE 0xEE\r\n+\r\n+**Validation Steps**:\r\n+- Verify request size >= 184 bytes\r\n+- Calculate coin count: (body_size - 179) / 5\r\n+- Verify PN[14:15] == 0xEE 0xEE\r\n+- Verify trade currency type is valid\r\n+- Verify address size (AS) is between 16-120 bytes\r\n+- Check no duplicate trade locker exists (same type, count, price)\r\n+\r\n+**Core Logic**:\r\n+1. Calculate XOR sum and total value of coins\r\n+2. If authentic (XOR matches):\r\n+   - Generate filesystem path from PN\r\n+   - Write crypto address to file\r\n+   - For each coin:\r\n+     - Update AN to PN in database\r\n+     - Queue page for persistence\r\n+3. Call trade_locker_index_add_coins(PN, coins, count)\r\n+\r\n+**Filesystem Storage**:\r\n+- Path: {config.cwd}/Trades/{PN_hex_string}\r\n+- Content: Crypto address (AS bytes)\r\n+\r\n+### 4.5. cmd_list_lockers_for_sale\r\n+**Purpose**: Lists available trade lockers.\r\n+\r\n+**Request Format**:\r\n+```\r\n+[16 bytes CH] [1 byte CT] [1 byte NR] [2 bytes EOF]\r\n+Size: exactly 20 bytes\r\n+```\r\n+\r\n+**Core Logic**:\r\n+1. Validate currency type (CT)\r\n+2. Allocate array for NR index entries\r\n+3. Call load_coins_from_trade_index(CT, NR, array)\r\n+4. For each returned entry:\r\n+   - Verify filesystem path exists\r\n+   - Calculate total value via calc_coins_in_trade_locker()\r\n+   - Add to output: [1 byte CT] [8 bytes value] [4 bytes price]\r\n+\r\n+**Response Format**:\r\n+```\r\n+[13 bytes per locker: CT + value + price]\r\n+```\r\n+\r\n+### 4.6. cmd_buy\r\n+**Purpose**: Transfers trade locker ownership with payment verification.\r\n+\r\n+**Request Format**:\r\n+```\r\n+[16 bytes CH] [16 bytes LK] [1 byte CT] [8 bytes AM] [4 bytes PRICE]\r\n+[32 bytes TXID] [16 bytes Receipt] [variable MEMO] [2 bytes EOF]\r\n+Minimum size: 96 bytes\r\n+```\r\n+\r\n+**Validation Steps**:\r\n+- Verify LK ends with 0xFF 0xFF 0xFF 0xFF\r\n+- Verify trade currency type\r\n+- Calculate memo size: body_size - 94\r\n+- Verify memo size <= 254\r\n+\r\n+**Complex Logic Flow**:\r\n+1. Find trade locker: get_entry_from_trade_index(CT, AM, PRICE)\r\n+2. Verify all coins still exist in database\r\n+3. Read seller's crypto address from filesystem\r\n+4. **Payment Verification (critical)**:\r\n+   - Get crypto private key for currency type\r\n+   - Build verification request:\r\n+     - Currency type\r\n+     - Receipt ID\r\n+     - Private key\r\n+     - Price\r\n+     - Seller address\r\n+     - Transaction ID\r\n+   - Send to external proxy: proxy_request(CMD_PROXY_SEND_TRANSACTION, ...)\r\n+   - Handle response:\r\n+     - STATUS_WAITING: Return immediately (async verification)\r\n+     - STATUS_SUCCESS: Continue with transfer\r\n+     - Other: Return error\r\n+5. **Transfer ownership**:\r\n+   - For each coin in trade locker:\r\n+     - Update AN to buyer's LK\r\n+     - Queue page for persistence\r\n+6. **Update indices atomically**:\r\n+   - trade_locker_index_remove_coins(seller_AN, coins, count)\r\n+   - locker_index_add_coins(buyer_LK, coins, count)\r\n+\r\n+**External Dependencies**:\r\n+- Crypto key storage system\r\n+- Payment verification proxy\r\n+- Filesystem for address storage\r\n+\r\n+### 4.7. cmd_store_multiple_sum\r\n+**Purpose**: Batch operation to create multiple lockers.\r\n+\r\n+**Request Format**:\r\n+```\r\n+[16 bytes CH] [1 byte NL] \r\n+For each locker:\r\n+  [2 bytes NC] [5 bytes per coin] [16 bytes SU] [16 bytes PN]\r\n+[2 bytes EOF]\r\n+Minimum size: 19 bytes\r\n+```\r\n+\r\n+**Validation Steps**:\r\n+- Verify NL > 0\r\n+- Pre-validate total size for all lockers\r\n+- Each locker must have valid structure\r\n+\r\n+**Core Logic**:\r\n+1. Allocate output bitmap: (NL / 8) + 1 bytes\r\n+2. For each locker:\r\n+   - Perform full cmd_store_sum logic\r\n+   - Track success/failure in bitmap\r\n+   - Continue on individual locker failure\r\n+3. Set status based on results:\r\n+   - All success: STATUS_ALL_PASS\r\n+   - All fail: STATUS_ALL_FAIL\r\n+   - Mixed: STATUS_MIXED (include bitmap in response)\r\n+\r\n+**Response Format**:\r\n+- Bitmap where bit N indicates success for locker N\r\n+\r\n+### 4.8. cmd_remove_trade_locker\r\n+**Purpose**: Removes coins from a trade locker.\r\n+\r\n+**Logic**: Identical to cmd_remove but:\r\n+- Uses get_coins_from_trade_index() instead of regular index\r\n+- Updates trade index via trade_locker_index_remove_coins()\r\n+\r\n+### 4.9. cmd_peek_trade_locker\r\n+**Purpose**: Views coins in a trade locker.\r\n+\r\n+**Logic**: Identical to cmd_peek but uses get_coins_from_trade_index()\r\n+\r\n+## 5. Critical Implementation Notes\r\n+\r\n+### 5.1 Database Page Management\r\n+For each page modification:\r\n+1. page = get_page_by_sn_lock(denomination, serial_number)\r\n+2. Modify page data\r\n+3. add_page_to_dirty_queue(page)\r\n+4. unlock_page(page)\r\n+\r\n+### 5.2 Serial Number Encoding\r\n+- **Storage**: 4 bytes big-endian\r\n+- **Functions**: get_sn(bytes) to decode, put_sn(value, bytes) to encode\r\n+\r\n+### 5.3 Statistics Tracking\r\n+After each successful coin update:\r\n+- inc_stat(POWN_FIELD_IDX, 1)\r\n+- inc_stat(POWN_VALUE_FIELD_IDX, get_den_value(denomination))\r\n+\r\n+### 5.4 Memory Safety\r\n+- Always free allocated memory on all code paths\r\n+- Check all allocations before use\r\n+- Clean up partial operations on failure\r\n+\r\n+### 5.5 Index Consistency\r\n+- Never update index before database\r\n+- Group related index updates together\r\n+- Ensure atomicity of paired operations (e.g., remove from one index, add to another)\r\n+\r\n+## 6. Error Recovery\r\n+\r\n+### 6.1 Partial Operation Failure\r\n+- In batch operations, continue processing remaining items\r\n+- Track individual successes/failures\r\n+- Return accurate status reflecting partial success\r\n+\r\n+### 6.2 External Service Failure\r\n+- Payment proxy timeout: Return STATUS_WAITING\r\n+- Filesystem errors: Log and return ERROR_FILESYSTEM\r\n+- Missing crypto keys: Return ERROR_NO_PRIVATE_KEY\r\n+\r\n+### 6.3 Database Inconsistency\r\n+- If page lock fails after initial success: Log error, attempt rollback\r\n+- If index update fails: Log critical error (indicates programming bug)\r\n+- Never leave database and index out of sync\r\n+\r\n+## 7. Performance Considerations\r\n+\r\n+### 7.1 Batch Processing\r\n+- Pre-allocate arrays for known sizes\r\n+- Minimize page locks held simultaneously\r\n+- Group sequential page accesses where possible\r\n+\r\n+### 7.2 Index Operations\r\n+- Perform bulk index updates in single call\r\n+- Avoid repeated index lookups for same AN\r\n+- Cache index results within command when safe\r\n+\r\n+### 7.3 I/O Optimization\r\n+- Queue dirty pages instead of synchronous writes\r\n+- Batch filesystem operations where possible\r\n+- Minimize crypto key file reads\n\\ No newline at end of file\n"
                },
                {
                    "date": 1751960012548,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -361,9 +361,9 @@\n \r\n \r\n ////////////////////\r\n \r\n-# Language-Agnostic Specification: Locker Command Handlers\r\n+#  Specification: Locker Command Handlers\r\n \r\n ## 1. Module Purpose\r\n This module implements the business logic for all commands related to coin lockers. These handlers interact with the primary database, validate client requests, and ensure the in-memory Locker Index is kept perfectly in sync with the state of the database.\r\n \r\n"
                }
            ],
            "date": 1751955397733,
            "name": "Commit-0",
            "content": "Language-Agnostic Specification: Locker Command Handlers\r\n1. Module Purpose\r\nThis module implements the business logic for all commands related to coin lockers. These handlers interact with the primary database, validate client requests, and ensure the in-memory Locker Index is kept perfectly in sync with the state of the database.\r\n2. Architectural Requirements\r\n2.1 Data Flow Order\r\n\r\nPrimary Data Source: All state changes must be written to the primary database first\r\nAsynchronous Persistence: Modified pages must be queued for disk write via add_page_to_dirty_queue()\r\nIndex Synchronization: In-memory index updates occur only after successful database modifications\r\n\r\n2.2 Transaction Integrity\r\n\r\nDatabase modifications must be atomic per command\r\nIndex updates must match database state exactly\r\nPartial failures must not corrupt either database or index\r\n\r\n3. Common Data Structures\r\n3.1 Request/Response Structure\r\nconn_info_t:\r\n  - body_size: Integer (total request size)\r\n  - command_status: Byte (response status code)\r\n  - output: Byte array (response data)\r\n  - output_size: Integer (response data length)\r\n3.2 Status Codes\r\n\r\nSTATUS_ALL_PASS: All operations successful\r\nSTATUS_ALL_FAIL: All operations failed\r\nSTATUS_MIXED: Partial success (batch operations)\r\nSTATUS_WAITING: Operation pending external verification\r\nERROR_INVALID_PACKET_LENGTH: Malformed request\r\nERROR_COINS_NOT_DIV: Coin data not properly aligned\r\nERROR_INVALID_SN_OR_DENOMINATION: Invalid coin identifier\r\nERROR_INVALID_PAN: Invalid proposed AN format\r\nERROR_INVALID_PARAMETER: General parameter error\r\nERROR_MEMORY_ALLOC: Memory allocation failure\r\nERROR_INTERNAL: Unexpected internal error\r\nERROR_TRADE_LOCKER_EXISTS: Duplicate trade locker\r\nERROR_TRADE_LOCKER_NOT_FOUND: Trade locker not found\r\nERROR_INVALID_TRADE_COIN: Invalid currency type\r\nERROR_FILESYSTEM: File I/O error\r\nERROR_NO_PRIVATE_KEY: Missing crypto key\r\n\r\n3.3 Constants\r\n\r\nCoin record size: 17 bytes (16 AN + 1 MFS)\r\nStandard locker AN suffix: 0xFF 0xFF 0xFF 0xFF\r\nTrade locker AN suffix: 0xEE 0xEE\r\nTrade type position: AN[13]\r\nPrice position: AN[9:12] (4 bytes, big-endian)\r\n\r\n4. Core Command Implementations\r\n4.1. cmd_store_sum\r\nPurpose: Creates or adds coins to a standard locker.\r\nRequest Format:\r\n[16 bytes CH] [5 bytes per coin (DN + 4 SN)] [16 bytes SU] [16 bytes PN] [2 bytes EOF]\r\nMinimum size: 55 bytes\r\nValidation Steps:\r\n\r\nVerify request size >= 55 bytes\r\nCalculate coin count: (body_size - 50) / 5\r\nVerify coin data is divisible by 5\r\nVerify PN ends with 0xFF 0xFF 0xFF 0xFF\r\n\r\nCore Logic:\r\n\r\nAllocate array for coins to be added\r\nCalculate XOR sum of current ANs:\r\nFor each coin:\r\n  - Extract denomination (1 byte) and SN (4 bytes)\r\n  - Lock database page containing coin\r\n  - XOR the coin's current AN into running sum\r\n  - Store coin info for later use\r\n  - Unlock page\r\n\r\nCompare calculated XOR with provided SU\r\nIf authentic:\r\nFor each coin:\r\n  - Lock database page\r\n  - Update coin's AN to PN\r\n  - Set MFS byte\r\n  - Call add_page_to_dirty_queue(page)\r\n  - Increment statistics\r\n  - Unlock page\r\n\r\nCall locker_index_add_coins(PN, coins_array, count)\r\nSet status to STATUS_ALL_PASS or STATUS_ALL_FAIL\r\n\r\nError Handling:\r\n\r\nFree allocated memory on any error\r\nReturn appropriate error code\r\nDo not update index if database update fails\r\n\r\n4.2. cmd_remove\r\nPurpose: Removes specific coins from a standard locker.\r\nRequest Format:\r\n[16 bytes CH] [16 bytes AN] [21 bytes per coin (DN + 4 SN + 16 CAN)] [2 bytes EOF]\r\nMinimum size: 55 bytes\r\nValidation Steps:\r\n\r\nVerify request size >= 55 bytes\r\nCalculate coin count: (body_size - 34) / 21\r\nVerify coin data is divisible by 21\r\n\r\nCore Logic:\r\n\r\nCall get_coins_from_index(AN) to get locker contents\r\nIf locker not found, return STATUS_ALL_FAIL\r\nAllocate output buffer: (coin_count / 8) + 1 bytes for bitmap\r\nFor each coin to remove:\r\n- Extract DN, SN, and new CAN from request\r\n- Verify coin exists in locker (search index entry)\r\n- If found:\r\n  * Lock database page\r\n  * Update coin's AN to CAN\r\n  * Set MFS byte\r\n  * Call add_page_to_dirty_queue(page)\r\n  * Set success bit in output bitmap\r\n  * Add to removal list\r\n  * Unlock page\r\n- If not found, increment failure count\r\n\r\nCall locker_index_remove_coins(AN, removal_list, removal_count)\r\nSet appropriate status based on success/failure counts\r\n\r\nResponse Format:\r\n\r\nBitmap where bit N indicates success (1) or failure (0) for coin N\r\n\r\n4.3. cmd_peek\r\nPurpose: Retrieves coins in a standard locker (read-only).\r\nRequest Format:\r\n[16 bytes CH] [16 bytes AN] [2 bytes EOF]\r\nSize: exactly 34 bytes\r\nCore Logic:\r\n\r\nValidate request size == 34\r\nCall get_coins_from_index(AN)\r\nIf not found, return STATUS_ALL_FAIL\r\nAllocate output buffer: num_coins * 5 bytes\r\nFor each coin in index entry:\r\n- Write denomination (1 byte)\r\n- Write SN (4 bytes, big-endian)\r\n\r\nSet status to STATUS_ALL_PASS\r\n\r\nResponse Format:\r\n[5 bytes per coin (DN + 4 SN)]\r\n4.4. cmd_put_for_sale\r\nPurpose: Creates a trade locker for selling coins.\r\nRequest Format:\r\n[16 bytes CH] [5 bytes per coin] [16 bytes SU] [16 bytes PN] \r\n[1 byte AS] [128 bytes AD] [2 bytes EOF]\r\nMinimum size: 184 bytes\r\nSpecial PN Format:\r\n\r\nPN[9:12]: Price (4 bytes, big-endian)\r\nPN[13]: Trade currency type\r\nPN[14:15]: Must be 0xEE 0xEE\r\n\r\nValidation Steps:\r\n\r\nVerify request size >= 184 bytes\r\nCalculate coin count: (body_size - 179) / 5\r\nVerify PN[14:15] == 0xEE 0xEE\r\nVerify trade currency type is valid\r\nVerify address size (AS) is between 16-120 bytes\r\nCheck no duplicate trade locker exists (same type, count, price)\r\n\r\nCore Logic:\r\n\r\nCalculate XOR sum and total value of coins\r\nIf authentic (XOR matches):\r\n- Generate filesystem path from PN\r\n- Write crypto address to file\r\n- For each coin:\r\n  * Update AN to PN in database\r\n  * Queue page for persistence\r\n\r\nCall trade_locker_index_add_coins(PN, coins, count)\r\n\r\nFilesystem Storage:\r\nPath: {config.cwd}/Trades/{PN_hex_string}\r\nContent: Crypto address (AS bytes)\r\n4.5. cmd_list_lockers_for_sale\r\nPurpose: Lists available trade lockers.\r\nRequest Format:\r\n[16 bytes CH] [1 byte CT] [1 byte NR] [2 bytes EOF]\r\nSize: exactly 20 bytes\r\nCore Logic:\r\n\r\nValidate currency type (CT)\r\nAllocate array for NR index entries\r\nCall load_coins_from_trade_index(CT, NR, array)\r\nFor each returned entry:\r\n- Verify filesystem path exists\r\n- Calculate total value via calc_coins_in_trade_locker()\r\n- Add to output: [1 byte CT] [8 bytes value] [4 bytes price]\r\n\r\n\r\nResponse Format:\r\n[13 bytes per locker: CT + value + price]\r\n4.6. cmd_buy\r\nPurpose: Transfers trade locker ownership with payment verification.\r\nRequest Format:\r\n[16 bytes CH] [16 bytes LK] [1 byte CT] [8 bytes AM] [4 bytes PRICE]\r\n[32 bytes TXID] [16 bytes Receipt] [variable MEMO] [2 bytes EOF]\r\nMinimum size: 96 bytes\r\nValidation Steps:\r\n\r\nVerify LK ends with 0xFF 0xFF 0xFF 0xFF\r\nVerify trade currency type\r\nCalculate memo size: body_size - 94\r\nVerify memo size <= 254\r\n\r\nComplex Logic Flow:\r\n\r\nFind trade locker: get_entry_from_trade_index(CT, AM, PRICE)\r\nVerify all coins still exist in database\r\nRead seller's crypto address from filesystem\r\nPayment Verification (critical):\r\n- Get crypto private key for currency type\r\n- Build verification request:\r\n  * Currency type\r\n  * Receipt ID\r\n  * Private key\r\n  * Price\r\n  * Seller address\r\n  * Transaction ID\r\n- Send to external proxy: proxy_request(CMD_PROXY_SEND_TRANSACTION, ...)\r\n- Handle response:\r\n  * STATUS_WAITING: Return immediately (async verification)\r\n  * STATUS_SUCCESS: Continue with transfer\r\n  * Other: Return error\r\n\r\nTransfer ownership:\r\nFor each coin in trade locker:\r\n  - Update AN to buyer's LK\r\n  - Queue page for persistence\r\n\r\nUpdate indices atomically:\r\n- trade_locker_index_remove_coins(seller_AN, coins, count)\r\n- locker_index_add_coins(buyer_LK, coins, count)\r\n\r\n\r\nExternal Dependencies:\r\n\r\nCrypto key storage system\r\nPayment verification proxy\r\nFilesystem for address storage\r\n\r\n4.7. cmd_store_multiple_sum\r\nPurpose: Batch operation to create multiple lockers.\r\nRequest Format:\r\n[16 bytes CH] [1 byte NL] \r\nFor each locker:\r\n  [2 bytes NC] [5 bytes per coin] [16 bytes SU] [16 bytes PN]\r\n[2 bytes EOF]\r\nMinimum size: 19 bytes\r\nValidation Steps:\r\n\r\nVerify NL > 0\r\nPre-validate total size for all lockers\r\nEach locker must have valid structure\r\n\r\nCore Logic:\r\n\r\nAllocate output bitmap: (NL / 8) + 1 bytes\r\nFor each locker:\r\n- Perform full cmd_store_sum logic\r\n- Track success/failure in bitmap\r\n- Continue on individual locker failure\r\n\r\nSet status based on results:\r\n\r\nAll success: STATUS_ALL_PASS\r\nAll fail: STATUS_ALL_FAIL\r\nMixed: STATUS_MIXED (include bitmap in response)\r\n\r\n\r\n\r\nResponse Format:\r\n\r\nBitmap where bit N indicates success for locker N\r\n\r\n4.8. cmd_remove_trade_locker\r\nPurpose: Removes coins from a trade locker.\r\nLogic: Identical to cmd_remove but:\r\n\r\nUses get_coins_from_trade_index() instead of regular index\r\nUpdates trade index via trade_locker_index_remove_coins()\r\n\r\n4.9. cmd_peek_trade_locker\r\nPurpose: Views coins in a trade locker.\r\nLogic: Identical to cmd_peek but uses get_coins_from_trade_index()\r\n5. Critical Implementation Notes\r\n5.1 Database Page Management\r\nFor each page modification:\r\n1. page = get_page_by_sn_lock(denomination, serial_number)\r\n2. Modify page data\r\n3. add_page_to_dirty_queue(page)\r\n4. unlock_page(page)\r\n5.2 Serial Number Encoding\r\n\r\nStorage: 4 bytes big-endian\r\nFunctions: get_sn(bytes) to decode, put_sn(value, bytes) to encode\r\n\r\n5.3 Statistics Tracking\r\nAfter each successful coin update:\r\ninc_stat(POWN_FIELD_IDX, 1)\r\ninc_stat(POWN_VALUE_FIELD_IDX, get_den_value(denomination))\r\n5.4 Memory Safety\r\n\r\nAlways free allocated memory on all code paths\r\nCheck all allocations before use\r\nClean up partial operations on failure\r\n\r\n5.5 Index Consistency\r\n\r\nNever update index before database\r\nGroup related index updates together\r\nEnsure atomicity of paired operations (e.g., remove from one index, add to another)\r\n\r\n6. Error Recovery\r\n6.1 Partial Operation Failure\r\n\r\nIn batch operations, continue processing remaining items\r\nTrack individual successes/failures\r\nReturn accurate status reflecting partial success\r\n\r\n6.2 External Service Failure\r\n\r\nPayment proxy timeout: Return STATUS_WAITING\r\nFilesystem errors: Log and return ERROR_FILESYSTEM\r\nMissing crypto keys: Return ERROR_NO_PRIVATE_KEY\r\n\r\n6.3 Database Inconsistency\r\n\r\nIf page lock fails after initial success: Log error, attempt rollback\r\nIf index update fails: Log critical error (indicates programming bug)\r\nNever leave database and index out of sync\r\n\r\n7. Performance Considerations\r\n7.1 Batch Processing\r\n\r\nPre-allocate arrays for known sizes\r\nMinimize page locks held simultaneously\r\nGroup sequential page accesses where possible\r\n\r\n7.2 Index Operations\r\n\r\nPerform bulk index updates in single call\r\nAvoid repeated index lookups for same AN\r\nCache index results within command when safe\r\n\r\n7.3 I/O Optimization\r\n\r\nQueue dirty pages instead of synchronous writes\r\nBatch filesystem operations where possible\r\nMinimize crypto key file reads"
        }
    ]
}