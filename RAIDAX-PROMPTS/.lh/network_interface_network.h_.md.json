{
    "sourceFile": "network_interface_network.h_.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1751889427465,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1751959353733,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,5 +22,321 @@\n \r\n 4. Architectural Notes\r\n The interface is designed to be abstract and can be implemented using any modern asynchronous I/O framework (e.g., epoll, kqueue, IOCP, libuv, asyncio, Netty).\r\n \r\n-The design separates the network I/O logic (this module) from the protocol-handling logic.\n\\ No newline at end of file\n+The design separates the network I/O logic (this module) from the protocol-handling logic.\r\n+\r\n+////////////////////////\r\n+\r\n+# Language-Agnostic Specification: CloudCoin Network Header Interface\r\n+\r\n+## 1. Module Purpose\r\n+This specification defines the public interface for the CloudCoin network layer. It establishes the constants, data structure requirements, and function signatures needed to implement a high-performance, event-driven network system supporting both TCP and UDP protocols.\r\n+\r\n+## 2. System Constants and Configuration\r\n+\r\n+### 2.1 Network Performance Parameters\r\n+```\r\n+RAIDA_EPOLL_TIMEOUT = 10000        // Timeout in milliseconds\r\n+MAXEPOLLSIZE = 10000               // Maximum events per wait operation\r\n+MAX_FDS = 65535                    // Maximum file descriptors\r\n+SOCKET_TIMEOUT = 2                 // Socket timeout in seconds\r\n+```\r\n+\r\n+### 2.2 Security and Resource Limits\r\n+```\r\n+MAX_BODY_SIZE = 65536              // Maximum request body size in bytes\r\n+```\r\n+\r\n+## 3. Core Data Structures\r\n+\r\n+### 3.1 Connection Information Requirements\r\n+The connection information structure must track the complete state of a network connection and include these logical components:\r\n+\r\n+**Socket and Network Information:**\r\n+- Socket file descriptor (integer)\r\n+- Client IP address (16-character array including null terminator)\r\n+- Socket address structure pointer (for UDP connections, dynamically allocated)\r\n+- Connection start timestamp (platform-specific time structure)\r\n+\r\n+**Connection State Management:**\r\n+- Current connection state (enumerated type)\r\n+- Read buffer for headers (fixed-size byte array of REQUEST_HEADER_SIZE)\r\n+- Bytes read in current operation (integer)\r\n+- Bytes expected for current operation (integer)\r\n+\r\n+**Dynamic Buffer Management:**\r\n+- Body buffer pointer (dynamically allocated byte array)\r\n+- Body size (integer)\r\n+- Write buffer pointer (dynamically allocated byte array)\r\n+- Bytes written in current operation (integer)\r\n+- Total bytes to write (integer)\r\n+- Output data pointer (processed response data)\r\n+\r\n+**Protocol Header Fields:**\r\n+- Session identifier (32-bit unsigned integer)\r\n+- Command type (8-bit unsigned integer)\r\n+- Protocol version (8-bit unsigned integer)\r\n+- RAIDA identifier (8-bit unsigned integer)\r\n+- Reserved field (8-bit unsigned integer)\r\n+\r\n+### 3.2 Connection State Enumeration\r\n+The system must support these connection states:\r\n+\r\n+| State Name              | Description                              |\r\n+|------------------------|------------------------------------------|\r\n+| STATE_WANT_READ_HEADER | Waiting to read complete request header  |\r\n+| STATE_WANT_READ_BODY   | Waiting to read complete request body    |\r\n+| STATE_PROCESSING       | Request being processed by worker thread |\r\n+| STATE_WANT_WRITE       | Ready to write response data             |\r\n+\r\n+## 4. Public Function Interface\r\n+\r\n+### 4.1 Main Network Functions\r\n+\r\n+#### 4.1.1 init_and_listen_sockets()\r\n+```\r\n+Function: init_and_listen_sockets\r\n+Parameters: none\r\n+Returns: integer (0 = success, negative = error)\r\n+Purpose: Initialize network layer and run main event loop\r\n+```\r\n+\r\n+#### 4.1.2 init_tcp_socket()\r\n+```\r\n+Function: init_tcp_socket\r\n+Parameters: none\r\n+Returns: integer (socket descriptor or negative on error)\r\n+Purpose: Create and configure TCP listening socket\r\n+```\r\n+\r\n+#### 4.1.3 init_udp_socket()\r\n+```\r\n+Function: init_udp_socket\r\n+Parameters: none\r\n+Returns: integer (socket descriptor or negative on error)\r\n+Purpose: Create and configure UDP socket\r\n+```\r\n+\r\n+### 4.2 Socket Configuration Functions\r\n+\r\n+#### 4.2.1 set_nonblocking(file_descriptor)\r\n+```\r\n+Function: set_nonblocking\r\n+Parameters: fd (integer file descriptor)\r\n+Returns: integer (0 = success, negative = error)\r\n+Purpose: Configure socket for non-blocking operation\r\n+```\r\n+\r\n+#### 4.2.2 set_blocking(file_descriptor)\r\n+```\r\n+Function: set_blocking\r\n+Parameters: fd (integer file descriptor)\r\n+Returns: integer (0 = success, negative = error)\r\n+Purpose: Configure socket for blocking operation\r\n+```\r\n+\r\n+### 4.3 Connection Management Functions\r\n+\r\n+#### 4.3.1 alloc_ci(socket)\r\n+```\r\n+Function: alloc_ci\r\n+Parameters: sk (integer socket file descriptor)\r\n+Returns: pointer to connection_info (NULL on allocation failure)\r\n+Purpose: Allocate and initialize connection information structure\r\n+```\r\n+\r\n+#### 4.3.2 free_ci(conn_info)\r\n+```\r\n+Function: free_ci\r\n+Parameters: ci (pointer to connection_info)\r\n+Returns: void\r\n+Purpose: Free all resources associated with connection information\r\n+```\r\n+\r\n+### 4.4 Event Handling Functions\r\n+\r\n+#### 4.4.1 handle_new_tcp_connection(tcp_socket)\r\n+```\r\n+Function: handle_new_tcp_connection\r\n+Parameters: tsocket (integer TCP listening socket)\r\n+Returns: void\r\n+Purpose: Accept and configure new TCP connections\r\n+```\r\n+\r\n+#### 4.4.2 handle_udp_request(udp_socket)\r\n+```\r\n+Function: handle_udp_request\r\n+Parameters: usocket (integer UDP socket)\r\n+Returns: void\r\n+Purpose: Process incoming UDP datagrams\r\n+```\r\n+\r\n+#### 4.4.3 handle_connection_event(conn_info, events)\r\n+```\r\n+Function: handle_connection_event\r\n+Parameters:\r\n+    ci (pointer to connection_info)\r\n+    events (32-bit unsigned integer event mask)\r\n+Returns: void\r\n+Purpose: Route connection events to appropriate handlers\r\n+```\r\n+\r\n+### 4.5 Cross-Thread Communication\r\n+\r\n+#### 4.5.1 arm_socket_for_write(conn_info)\r\n+```\r\n+Function: arm_socket_for_write\r\n+Parameters: ci (pointer to connection_info)\r\n+Returns: void\r\n+Purpose: Signal main I/O thread that socket is ready for writing\r\n+Thread Context: Called by worker threads after processing requests\r\n+```\r\n+\r\n+## 5. Function Signature Corrections\r\n+\r\n+Note: The header file contains function signatures that differ from the implementation:\r\n+\r\n+### 5.1 Signature Discrepancies\r\n+- handle_new_tcp_connection: Header declares extra epoll_fd parameter not used in implementation\r\n+- handle_udp_request: Header declares extra epoll_fd parameter not used in implementation  \r\n+- handle_connection_event: Header declares extra epoll_fd parameter not used in implementation\r\n+\r\n+### 5.2 Implementation Requirement\r\n+Implementations should follow the actual function signatures used in the implementation rather than the header declarations for these three functions.\r\n+\r\n+## 6. Memory Management Requirements\r\n+\r\n+### 6.1 Allocation Strategy\r\n+- Connection information structures: Dynamically allocated per connection\r\n+- Body buffers: Dynamically allocated when request body is present\r\n+- Write buffers: Dynamically allocated for response data\r\n+- Socket address structures: Dynamically allocated for UDP connections only\r\n+\r\n+### 6.2 Deallocation Requirements\r\n+The free_ci function must handle cleanup of:\r\n+- Socket address structure (if not NULL)\r\n+- Body buffer (if not NULL)\r\n+- Output buffer (if not NULL)\r\n+- Write buffer (if not NULL)\r\n+- Main connection structure\r\n+- Must handle NULL input parameter gracefully\r\n+\r\n+## 7. Initialization Requirements\r\n+\r\n+### 7.1 Connection Structure Initialization\r\n+When allocating connection information, implementations must:\r\n+- Initialize all fields to zero\r\n+- Set socket descriptor to provided value\r\n+- Set initial state to STATE_WANT_READ_HEADER\r\n+- Set bytes_to_read to REQUEST_HEADER_SIZE\r\n+- Record current timestamp as start time\r\n+\r\n+### 7.2 Socket Configuration Requirements\r\n+TCP sockets must be configured with:\r\n+- SO_REUSEADDR option enabled\r\n+- Non-blocking mode enabled\r\n+- TCP keep-alive enabled with specific parameters:\r\n+  - keepalive = 1\r\n+  - keep_idle = 60 seconds\r\n+  - keep_interval = 10 seconds\r\n+  - keep_count = 5 probes\r\n+\r\n+UDP sockets must be configured with:\r\n+- Non-blocking mode enabled\r\n+\r\n+## 8. Error Handling Standards\r\n+\r\n+### 8.1 Return Code Conventions\r\n+- Success operations return 0\r\n+- Error conditions return negative values\r\n+- Pointer-returning functions return NULL on error\r\n+- All system errors should be logged with context\r\n+\r\n+### 8.2 Resource Cleanup\r\n+- All allocated resources must be freed on error paths\r\n+- Connection cleanup must remove from all tracking structures\r\n+- Socket file descriptors must be closed on connection termination\r\n+- Error responses should be sent before closing connections when possible\r\n+\r\n+## 9. Threading and Concurrency\r\n+\r\n+### 9.1 Thread Safety Requirements\r\n+- Main network functions execute in single I/O thread\r\n+- Connection structures accessed by single thread at a time during processing\r\n+- Cross-thread communication uses thread-safe signaling mechanism\r\n+- Worker threads call arm_socket_for_write to signal completion\r\n+\r\n+### 9.2 Synchronization Points\r\n+- Write queue operations require mutex protection\r\n+- EventFD signaling provides cross-thread communication\r\n+- Connection state transitions managed by single thread\r\n+\r\n+## 10. Integration Dependencies\r\n+\r\n+### 10.1 External Constants Required\r\n+- REQUEST_HEADER_SIZE: Size of protocol request header\r\n+- NO_ERROR: Success status code from protocol layer\r\n+- ERROR_INVALID_PACKET_LENGTH: Protocol error for size validation\r\n+- ERROR_MEMORY_ALLOC: Protocol error for allocation failures\r\n+\r\n+### 10.2 External Function Dependencies\r\n+- validate_header: Protocol header validation\r\n+- validate_decrypt_body: Protocol body validation and decryption\r\n+- run_command: Request processing function\r\n+- send_command_error: Error response transmission\r\n+- Thread pool functions for work submission\r\n+- Logging functions for debug and error output\r\n+- Statistics functions for request counting\r\n+\r\n+### 10.3 Configuration Access Required\r\n+- config.port: Network port number for binding\r\n+- config.udp_payload_threshold: Maximum UDP packet size\r\n+- is_finished: Global shutdown signal\r\n+\r\n+## 11. Platform Abstraction\r\n+\r\n+### 11.1 Required Abstractions\r\n+Implementations must provide platform-appropriate equivalents for:\r\n+- Event notification mechanism (epoll on Linux)\r\n+- Cross-thread signaling (eventfd on Linux)\r\n+- Socket API (POSIX sockets)\r\n+- Threading primitives (POSIX threads)\r\n+- File descriptor management\r\n+- Non-blocking I/O configuration\r\n+\r\n+### 11.2 Type System Requirements\r\n+- Integer types: Standard signed and unsigned integers\r\n+- Pointer types: For dynamic memory management\r\n+- Network address types: Platform socket address structures\r\n+- Time types: Platform timestamp structures\r\n+- Thread synchronization types: Platform mutex primitives\r\n+\r\n+## 12. Performance Considerations\r\n+\r\n+### 12.1 Scalability Requirements\r\n+- Support for thousands of concurrent connections\r\n+- Non-blocking operations throughout\r\n+- Efficient event notification mechanism\r\n+- Minimal memory allocation during steady-state operation\r\n+\r\n+### 12.2 Resource Management\r\n+- Connection limits enforced by MAX_FDS constant\r\n+- Body size limits enforced by MAX_BODY_SIZE constant\r\n+- Timeout mechanisms for connection cleanup\r\n+- Efficient cleanup of terminated connections\r\n+\r\n+## 13. Security Interface\r\n+\r\n+### 13.1 Input Validation\r\n+- All header fields must be validated before use\r\n+- Body size must not exceed MAX_BODY_SIZE\r\n+- Buffer operations must include bounds checking\r\n+- Malformed requests must be rejected gracefully\r\n+\r\n+### 13.2 Resource Protection\r\n+- Connection limits prevent resource exhaustion\r\n+- Memory limits prevent excessive allocation\r\n+- Timeout mechanisms prevent connection hoarding\r\n+- Error responses prevent information leakage\r\n+\r\n+This specification provides the complete interface definition needed to implement a high-performance network layer while remaining language-agnostic and accurately reflecting the actual implementation requirements.\n\\ No newline at end of file\n"
                },
                {
                    "date": 1751960045920,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n The design separates the network I/O logic (this module) from the protocol-handling logic.\r\n \r\n ////////////////////////\r\n \r\n-# Language-Agnostic Specification: CloudCoin Network Header Interface\r\n+#  Specification: CloudCoin Network Header Interface\r\n \r\n ## 1. Module Purpose\r\n This specification defines the public interface for the CloudCoin network layer. It establishes the constants, data structure requirements, and function signatures needed to implement a high-performance, event-driven network system supporting both TCP and UDP protocols.\r\n \r\n"
                }
            ],
            "date": 1751889427465,
            "name": "Commit-0",
            "content": "Language-Agnostic Specification: Network Interface\r\n1. Module Purpose\r\nThis module defines the public interface for the RAIDAX server's high-performance, non-blocking network layer. It specifies the required functions and constants for initializing and running the server's network event loop.\r\n\r\n2. Core Constants\r\nEVENT_LOOP_TIMEOUT: An integer representing the timeout for the I/O event multiplexer in milliseconds (e.g., 10000).\r\n\r\nMAX_CONNECTIONS: The maximum number of concurrent connections the server is configured to handle (e.g., 65535).\r\n\r\nMAX_BODY_SIZE: A constant defining the maximum allowed size for a request body (e.g., 65536 bytes). This is a critical security measure.\r\n\r\n3. Required Functions\r\nThe network layer implementation must expose the following functionalities:\r\n\r\nstart_server_event_loop(): The main entry point for the network layer. It initializes the server sockets, sets up the asynchronous I/O event multiplexer, and starts the main event loop. This function should block indefinitely.\r\n\r\ninitialize_tcp_listener(): Creates, binds, and listens on the primary TCP socket, configuring it for non-blocking operation. Returns a handle to the listening socket.\r\n\r\ninitialize_udp_socket(): Creates and binds the primary UDP socket, configuring it for non-blocking operation. Returns a handle to the UDP socket.\r\n\r\narm_socket_for_write(connection_object): A thread-safe function that allows a worker thread to signal the main I/O thread that a connection is ready to be written to.\r\n\r\n4. Architectural Notes\r\nThe interface is designed to be abstract and can be implemented using any modern asynchronous I/O framework (e.g., epoll, kqueue, IOCP, libuv, asyncio, Netty).\r\n\r\nThe design separates the network I/O logic (this module) from the protocol-handling logic."
        }
    ]
}