{
    "sourceFile": "crossover_implementation_crossover.c.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1751973780247,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1751973780247,
            "name": "Commit-0",
            "content": "# Language-Agnostic Specification: Crossover Implementation\r\n\r\n## 1. Module Purpose\r\nThis module implements the crossover system for the CloudCoin RAIDA network, enabling cross-network cryptocurrency transactions and exchange operations. It manages a time-based index of pending transactions, provides optimized background processing with dynamic sleep scheduling, and handles secure communication with external proxy services for cryptocurrency operations.\r\n\r\n## 2. System Architecture Overview\r\n\r\n### 2.1 Core Components\r\n- **Time-Based Transaction Index**: Memory-based tracking of pending crossover transactions\r\n- **Optimized Background Processing**: Dynamic sleep scheduling based on transaction expiry times\r\n- **Secure Proxy Communication**: Encrypted communication with external cryptocurrency services\r\n- **Exchange Rate Management**: Real-time cryptocurrency exchange rate retrieval\r\n- **Transaction Validation**: Multi-step verification process for cross-network operations\r\n\r\n### 2.2 Processing Flow\r\n- **Transaction Registration**: Add pending transactions to time-indexed system\r\n- **Dynamic Monitoring**: Background thread with intelligent sleep scheduling\r\n- **Proxy Integration**: Secure communication for transaction verification and execution\r\n- **Automatic Cleanup**: Time-based expiry and removal of stale transactions\r\n\r\n## 3. System Constants and Configuration\r\n\r\n### 3.1 Index Management Constants\r\n```\r\nMAX_CROSSOVER_RECORDS = maximum concurrent crossover transactions\r\nCROSSOVER_EXPIRY = transaction expiry time in seconds\r\nCROSSOVER_HOUSEKEEPING_PERIOD = maximum background thread sleep duration\r\nMAX_MEMO_SIZE = maximum memo field size in bytes\r\n```\r\n\r\n### 3.2 Cryptocurrency Constants\r\n```\r\nBTC_KEY_MAX_SIZE = 3000 bytes          // Maximum cryptocurrency key size\r\nRESPONSE_HEADER_SIZE = 32 bytes        // Proxy response header size\r\nREQUEST_HEADER_SIZE = 32 bytes         // Proxy request header size\r\nRAIDA_SERVER_RCV_TIMEOUT = timeout for proxy communication\r\n```\r\n\r\n### 3.3 Proxy Command Constants\r\n```\r\nCMD_PROXY_WATCH_FOR_TRANSACTION = monitor transaction status\r\nCMD_PROXY_GET_RATE = retrieve exchange rates\r\nCMD_PROXY_SEND_TRANSACTION = execute transaction\r\nCROSSOVER = command group identifier for proxy operations\r\n```\r\n\r\n### 3.4 Status Response Codes\r\n```\r\nSTATUS_SUCCESS = successful operation\r\nSTATUS_WAITING = operation pending confirmation\r\nSTATUS_TX_SEEN = transaction detected but not confirmed\r\nERROR_NO_ENTRY = crossover entry not found\r\nERROR_INVALID_PARAMETER = invalid input parameters\r\nERROR_AMOUNT_MISMATCH = transaction amount verification failure\r\nERROR_NO_PRIVATE_KEY = cryptocurrency key not available\r\nERROR_INTERNAL = unexpected system error\r\nERROR_PROXY_CONNECT = proxy communication failure\r\nERROR_PROXY = proxy operation error\r\n```\r\n\r\n## 4. Data Structures\r\n\r\n### 4.1 Crossover Index Entry Structure\r\nEach crossover transaction entry must contain:\r\n- **Completion Status**: Boolean flag indicating transaction completion\r\n- **Amount**: 64-bit unsigned integer for transaction value\r\n- **Locker Key**: 16-byte identifier linking to coin locker\r\n- **Currency Code**: 3-byte cryptocurrency identifier (e.g., \"BTC\")\r\n- **Sender Address**: 32-byte cryptocurrency address\r\n- **Receipt ID**: 16-byte unique transaction identifier\r\n- **Memo**: Variable-length text field (up to MAX_MEMO_SIZE)\r\n- **Address Size**: Integer indicating actual address length used\r\n- **First Seen**: Timestamp for transaction creation and expiry calculation\r\n- **Confirmations**: Count of blockchain confirmations received\r\n\r\n### 4.2 Global Index Structure\r\n```\r\ncrossover_index: array[MAX_CROSSOVER_RECORDS] of pointer_to_crossover_entry\r\ncrossover_mutex: mutex_type for thread-safe access\r\n```\r\n\r\n## 5. Core Index Operations\r\n\r\n### 5.1 init_crossover_index()\r\n**Purpose**: Initialize crossover system and launch background processing thread.\r\n\r\n**Initialization Steps**:\r\n1. **Mutex Initialization**: Create mutex for thread-safe index access\r\n2. **Index Clearing**: Set all index entries to NULL\r\n3. **Thread Launch**: Start background housekeeping thread\r\n4. **Error Handling**: Return appropriate error codes for failures\r\n\r\n### 5.2 add_crossover_index_entry(parameters)\r\n**Purpose**: Add new crossover transaction to the index.\r\n\r\n**Parameters**:\r\n- locker_key: 16-byte locker identifier\r\n- currency_code: 3-byte currency identifier\r\n- amount: 64-bit transaction amount\r\n- sender_address: 32-byte sender address\r\n- address_size: actual address length\r\n- receipt_id: 16-byte receipt identifier\r\n- memo: variable-length memo text\r\n- memo_length: memo text length\r\n\r\n**Processing Logic**:\r\n1. **Slot Allocation**: Find first available index slot\r\n2. **Memory Allocation**: Allocate crossover entry structure\r\n3. **Data Population**: Copy all provided parameters to entry\r\n4. **Timestamp Setting**: Record current time as first_seen\r\n5. **Index Registration**: Place entry in allocated slot\r\n6. **Thread Safety**: Use mutex protection throughout\r\n\r\n**Return Values**:\r\n- 0: Success\r\n- -1: Memory allocation failure\r\n- -2: Index full (no available slots)\r\n\r\n### 5.3 get_crossover_index_entry(locker_key)\r\n**Purpose**: Retrieve crossover entry by locker key.\r\n\r\n**Processing Logic**:\r\n1. **Index Search**: Linear search through all active entries\r\n2. **Key Comparison**: Compare 16-byte locker keys for exact match\r\n3. **Thread Safety**: Use mutex protection during search\r\n4. **Return Management**: Return pointer to found entry or NULL\r\n\r\n## 6. Optimized Background Processing\r\n\r\n### 6.1 crossover_thread()\r\n**Purpose**: Background thread with dynamic sleep scheduling for efficient processing.\r\n\r\n**Optimization Algorithm**:\r\n1. **Immediate Cleanup**: Remove any expired transactions\r\n2. **Expiry Calculation**: Find next transaction expiry time\r\n3. **Dynamic Sleep**: Calculate sleep duration based on closest expiry\r\n4. **Maximum Limit**: Cap sleep duration at CROSSOVER_HOUSEKEEPING_PERIOD\r\n5. **Responsive Wakeup**: Sleep for minimal time if transactions already expired\r\n\r\n**Sleep Duration Logic**:\r\n- If next_expiry > current_time: sleep = next_expiry - current_time\r\n- If next_expiry <= current_time: sleep = 1 second (immediate processing)\r\n- If no active transactions: sleep = CROSSOVER_HOUSEKEEPING_PERIOD\r\n- Maximum sleep duration capped at CROSSOVER_HOUSEKEEPING_PERIOD\r\n\r\n### 6.2 housekeeping_crossover_index()\r\n**Purpose**: Remove expired transactions from the index.\r\n\r\n**Processing Logic**:\r\n1. **Current Time**: Get current timestamp\r\n2. **Index Iteration**: Check each active entry for expiry\r\n3. **Expiry Check**: Compare (first_seen + CROSSOVER_EXPIRY) with current time\r\n4. **Resource Cleanup**: Free expired entries and clear index slots\r\n5. **Thread Safety**: Use mutex protection during cleanup\r\n\r\n## 7. Cryptocurrency Operations\r\n\r\n### 7.1 check_depository(parameters)\r\n**Purpose**: Verify cryptocurrency transaction status and confirmations.\r\n\r\n**Parameters**:\r\n- locker_key: 16-byte locker identifier\r\n- currency_code: 3-byte currency identifier\r\n- transaction_id: 32-byte blockchain transaction ID\r\n- receipt_id: 16-byte receipt identifier\r\n- memo: variable-length memo text\r\n- memo_length: memo text length\r\n\r\n**Processing Logic**:\r\n1. **Entry Retrieval**: Get crossover entry by locker key\r\n2. **Parameter Validation**: Verify receipt ID and currency code match\r\n3. **Request Construction**: Build proxy request with transaction details\r\n4. **Proxy Communication**: Send watch transaction request to proxy\r\n5. **Response Processing**: Parse amount and confirmation count\r\n6. **Status Update**: Update entry with confirmation information\r\n\r\n**Return Handling**:\r\n- STATUS_SUCCESS: Transaction confirmed\r\n- STATUS_TX_SEEN: Transaction detected but not confirmed\r\n- ERROR_NO_ENTRY: Crossover entry not found\r\n- ERROR_INVALID_PARAMETER: Parameter validation failure\r\n- ERROR_AMOUNT_MISMATCH: Transaction amount doesn't match\r\n\r\n### 7.2 get_exchange_rate(currency_code, exchange_rate_output)\r\n**Purpose**: Retrieve current cryptocurrency exchange rate.\r\n\r\n**Processing Logic**:\r\n1. **Currency Validation**: Verify currency code (currently supports \"BTC\")\r\n2. **Proxy Request**: Send rate request to proxy service\r\n3. **Response Processing**: Extract 64-bit exchange rate value\r\n4. **Byte Order**: Handle big-endian to host byte order conversion\r\n5. **Output Setting**: Set exchange rate output parameter\r\n\r\n### 7.3 withdraw_from_depository(parameters)\r\n**Purpose**: Execute cryptocurrency withdrawal transaction.\r\n\r\n**Parameters**:\r\n- locker_key: 16-byte locker identifier\r\n- target_address: destination cryptocurrency address\r\n- address_size: target address length\r\n- conversion_cost: 64-bit withdrawal amount\r\n- currency_code: 3-byte currency identifier\r\n- receipt_id: 16-byte receipt identifier\r\n- memo: variable-length memo text\r\n- memo_length: memo text length\r\n\r\n**Processing Logic**:\r\n1. **Currency Validation**: Verify supported currency type\r\n2. **Key Retrieval**: Get cryptocurrency private key using get_crypto_key()\r\n3. **Key Size Validation**: Ensure key size within limits\r\n4. **Request Construction**: Build withdrawal request with all parameters\r\n5. **Proxy Communication**: Send transaction request to proxy\r\n6. **Response Handling**: Process success or waiting status\r\n\r\n**Security Considerations**:\r\n- Private key retrieved from secure filesystem\r\n- Key memory freed immediately after use\r\n- Encrypted communication with proxy service\r\n\r\n## 8. Secure Proxy Communication\r\n\r\n### 8.1 proxy_request(command, body, body_size, output_length, status)\r\n**Purpose**: Handle secure communication with external proxy services.\r\n\r\n**Parameters**:\r\n- command_no: integer command identifier\r\n- body: pointer to request body data\r\n- body_size: size of request body\r\n- output_length: pointer for response length output\r\n- status: pointer for status code output\r\n\r\n**Connection Management**:\r\n1. **Socket Creation**: Create TCP socket for proxy communication\r\n2. **Non-Blocking Connect**: Use non-blocking connection with timeout\r\n3. **Connection Validation**: Verify connection establishment with select()\r\n4. **Blocking Mode**: Switch to blocking mode for data transfer\r\n\r\n**Request Construction**:\r\n1. **Header Building**: Construct 32-byte request header\r\n2. **Encryption Setup**: Use AES encryption with proxy key\r\n3. **Body Encryption**: Encrypt request body and challenge\r\n4. **Trailer Addition**: Add 2-byte trailer (0x3e, 0x3e)\r\n\r\n**Response Processing**:\r\n1. **Header Reception**: Read 32-byte response header\r\n2. **Status Extraction**: Get operation status from header\r\n3. **Body Reception**: Read variable-length response body\r\n4. **Trailer Validation**: Verify 2-byte trailer presence\r\n5. **Body Decryption**: Decrypt response body content\r\n\r\n**Error Handling**:\r\n- Connection timeout: Return ERROR_PROXY_CONNECT\r\n- Invalid response: Return appropriate error code\r\n- Memory allocation failure: Clean up and return NULL\r\n- Network errors: Close socket and return error\r\n\r\n## 9. Memory Management\r\n\r\n### 9.1 Dynamic Allocation Strategy\r\n- **Index Entries**: Allocated on-demand for active transactions\r\n- **Response Buffers**: Sized based on actual response length\r\n- **Proxy Requests**: Temporary allocation for request construction\r\n- **Cryptocurrency Keys**: Temporary allocation with immediate cleanup\r\n\r\n### 9.2 Resource Cleanup Requirements\r\n- **Entry Expiry**: Free expired crossover entries automatically\r\n- **Network Resources**: Close sockets on all exit paths\r\n- **Memory Buffers**: Free all allocated buffers on error conditions\r\n- **Security Data**: Immediately free sensitive data like private keys\r\n\r\n### 9.3 Thread Safety\r\n- **Mutex Protection**: All index operations use mutex synchronization\r\n- **Atomic Operations**: Entry allocation and deallocation are atomic\r\n- **Resource Sharing**: Safe sharing of read-only configuration data\r\n\r\n## 10. Error Handling and Recovery\r\n\r\n### 10.1 Network Error Management\r\n- **Connection Failures**: Retry logic not implemented, return appropriate errors\r\n- **Timeout Handling**: Use select() for non-blocking connection management\r\n- **Socket Errors**: Log specific error messages and clean up resources\r\n- **Proxy Unavailability**: Return ERROR_PROXY_CONNECT for connection issues\r\n\r\n### 10.2 Transaction Error Management\r\n- **Invalid Parameters**: Validate all input parameters before processing\r\n- **Missing Entries**: Return ERROR_NO_ENTRY for unfound transactions\r\n- **Amount Mismatches**: Verify transaction amounts match expectations\r\n- **Confirmation Delays**: Handle STATUS_TX_SEEN for pending confirmations\r\n\r\n### 10.3 System Error Management\r\n- **Memory Exhaustion**: Return appropriate error codes for allocation failures\r\n- **Index Overflow**: Return -2 when index reaches capacity\r\n- **Thread Failures**: Log thread creation errors and return system errors\r\n- **Key Management**: Handle missing or invalid cryptocurrency keys\r\n\r\n## 11. Integration Requirements\r\n\r\n### 11.1 Configuration Dependencies\r\n- **Proxy Settings**: Access to proxy_addr, proxy_port, proxy_key\r\n- **Network Settings**: Access to coin_id, raida_no configuration\r\n- **Security Settings**: Access to btc_confirmations threshold\r\n- **Filesystem Access**: Integration with get_crypto_key() function\r\n\r\n### 11.2 Cryptographic Dependencies\r\n- **AES Encryption**: crypt_ctr() function for proxy communication\r\n- **CRC Calculation**: crc32b() function for request integrity\r\n- **Byte Order**: swap_uint64() for network byte order conversion\r\n- **Network Utilities**: put_u32() for data serialization\r\n\r\n### 11.3 Network Dependencies\r\n- **Socket Management**: set_nonblocking(), set_blocking() functions\r\n- **Address Resolution**: inet_pton() for IP address conversion\r\n- **Timeout Handling**: setsockopt() for socket timeout configuration\r\n- **Connection Management**: Standard TCP socket operations\r\n\r\n## 12. Performance Considerations\r\n\r\n### 12.1 Optimization Features\r\n- **Dynamic Sleep**: Background thread sleeps based on actual transaction expiry times\r\n- **Minimal Locking**: Mutex usage limited to critical sections\r\n- **Efficient Search**: Linear search acceptable for reasonable record limits\r\n- **Resource Reuse**: Index slots reused after transaction expiry\r\n\r\n### 12.2 Scalability Factors\r\n- **Index Size**: MAX_CROSSOVER_RECORDS determines concurrent transaction limit\r\n- **Memory Usage**: Each entry consumes fixed memory footprint\r\n- **Thread Overhead**: Single background thread minimizes resource usage\r\n- **Network Efficiency**: Persistent connections not implemented (single-use)\r\n\r\n### 12.3 Response Time Optimization\r\n- **Immediate Processing**: Expired transactions processed immediately\r\n- **Responsive Scheduling**: Background thread wakes up when needed\r\n- **Network Timeouts**: Configurable timeouts prevent hanging operations\r\n- **Error Fast-Path**: Quick return for common error conditions\r\n\r\nThis specification provides complete implementation guidance for the CloudCoin crossover system while remaining language-agnostic and accurately reflecting the optimized time-based processing architecture."
        }
    ]
}