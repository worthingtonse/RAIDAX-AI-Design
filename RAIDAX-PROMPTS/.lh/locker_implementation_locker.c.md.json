{
    "sourceFile": "locker_implementation_locker.c.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1751955135842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1751959972127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -273,5 +273,246 @@\n \r\n All public functions are thread-safe\r\n Internal functions ending in _internal require caller to hold appropriate lock\r\n No function should return while holding a lock\r\n-Index Entry Objects returned by query functions must not be modified by callers\n\\ No newline at end of file\n+Index Entry Objects returned by query functions must not be modified by callers\r\n+\r\n+\r\n+/////////////////////////////////////////////////////////////\r\n+\r\n+\r\n+# Language-Agnostic Specification: Locker Index Implementation\r\n+\r\n+## 1. Module Purpose\r\n+This module provides the concrete implementation for the in-memory Locker Index. It is responsible for the one-time initial build of the index and for providing thread-safe functions for incremental updates for both standard and trade lockers.\r\n+\r\n+## 2. Data Model Summary\r\n+\r\n+### 2.1 Core Data Structures\r\n+\r\n+**Locker Indices**: Two separate, global, thread-safe collections (array/map) must be maintained:\r\n+- **locker_index**: Array of pointers to Index Entry Objects (size: MAX_LOCKER_RECORDS = 10000)\r\n+- **trade_locker_index**: Array of pointers to Index Entry Objects (size: MAX_LOCKER_RECORDS = 10000)\r\n+\r\n+**Index Entry Object**:\r\n+- an: 16-byte array (Authenticity Number)\r\n+- coins: Dynamic array of Coin objects\r\n+- num_coins: Integer count of coins in the array\r\n+\r\n+**Coin Object**:\r\n+- denomination: 8-bit signed integer (valid range: MIN_DENOMINATION to MAX_DENOMINATION)\r\n+- sn: 32-bit unsigned integer (serial number)\r\n+\r\n+### 2.2 Locking Mechanism\r\n+\r\n+Two separate mutexes:\r\n+- **locker_mtx**: Protects the standard locker index\r\n+- **trade_locker_mtx**: Protects the trade locker index\r\n+\r\n+### 2.3 Constants\r\n+- **PREALLOCATE_COINS**: 100 (initial allocation size for coins array)\r\n+- **RECORDS_PER_PAGE**: Number of coin records per database page\r\n+- **TOTAL_PAGES**: Total number of pages per denomination\r\n+- **MIN_DENOMINATION, MAX_DENOMINATION**: Valid denomination range\r\n+\r\n+## 3. Architectural Requirements\r\n+- **One-Time Build**: The indices must be fully populated from the primary database on disk only once when the server starts.\r\n+- **No Background Thread**: There should be no periodic rebuilding thread.\r\n+- **Incremental Updates**: All modifications after startup must be handled incrementally.\r\n+- **Concurrency**: Thread-safe operations using fine-grained locking per index type.\r\n+- **Memory Management**: Dynamic allocation with pre-allocation strategy for performance.\r\n+\r\n+## 4. Core Logic and Implementation Details\r\n+\r\n+### 4.1. initialize_locker_index()\r\n+**Purpose**: Initialize the index system at server startup.\r\n+\r\n+**Logic**:\r\n+1. Initialize both index arrays to NULL pointers\r\n+2. Initialize both mutexes (locker_mtx, trade_locker_mtx)\r\n+3. Call build_initial_locker_indices()\r\n+4. Return 0 on success, -1 on failure\r\n+\r\n+**Error Handling**: Log and return error if mutex initialization fails.\r\n+\r\n+### 4.2. build_initial_locker_indices()\r\n+**Purpose**: One-time build of indices from disk database.\r\n+\r\n+**Logic**:\r\n+1. Acquire both locks (locker_mtx and trade_locker_mtx)\r\n+2. Clear any existing index entries (call free_index() and free_trade_index())\r\n+3. For each denomination (MIN_DENOMINATION to MAX_DENOMINATION):\r\n+   - For each page (0 to TOTAL_PAGES-1):\r\n+     - Lock and retrieve the page from database\r\n+     - For each record in page (0 to RECORDS_PER_PAGE-1):\r\n+       - Calculate serial number: sn = page_number * RECORDS_PER_PAGE + record_index\r\n+       - Extract AN from record (offset: record_index * 17, length: 16 bytes)\r\n+       - Check AN format:\r\n+         - If bytes 12-15 are all 0xFF: Add to standard locker index\r\n+         - If byte 13 is valid trade type AND bytes 14-15 are 0xEE: Add to trade index\r\n+     - Unlock the page\r\n+4. Release both locks\r\n+\r\n+**Trade Type Validation**: Valid types are SALE_TYPE_CC, SALE_TYPE_BTC, SALE_TYPE_XMR\r\n+\r\n+### 4.3. locker_index_add_coins(an, coins_array, num_coins)\r\n+**Purpose**: Add coins to a standard locker.\r\n+\r\n+**Parameters**:\r\n+- an: 16-byte array (locker identifier)\r\n+- coins_array: Array of Coin objects to add\r\n+- num_coins: Number of coins to add\r\n+\r\n+**Logic**:\r\n+1. Acquire locker_mtx\r\n+2. For each coin in coins_array:\r\n+   - Call internal add_index_entry_internal(coin.denomination, coin.sn, an)\r\n+3. Release locker_mtx\r\n+\r\n+### 4.4. trade_locker_index_add_coins(an, coins_array, num_coins)\r\n+**Purpose**: Add coins to a trade locker.\r\n+\r\n+**Logic**: Same as 4.3 but uses trade_locker_mtx and add_trade_index_entry_internal()\r\n+\r\n+### 4.5. Internal add_index_entry_internal(denomination, sn, an)\r\n+**Purpose**: Add a single coin to an index entry (mutex must be held by caller).\r\n+\r\n+**Logic**:\r\n+1. Search index array for matching AN or first NULL slot\r\n+2. If new entry (NULL slot found):\r\n+   - Allocate new Index Entry Object\r\n+   - Allocate coins array with PREALLOCATE_COINS capacity\r\n+   - Set num_coins = 1\r\n+   - Copy AN and add first coin\r\n+3. If existing entry found:\r\n+   - Check if reallocation needed: (num_coins % PREALLOCATE_COINS) == 0\r\n+   - If yes:\r\n+     - Calculate new size: ((num_coins / PREALLOCATE_COINS) + 1) * PREALLOCATE_COINS\r\n+     - Allocate new array, copy old data, free old array\r\n+   - Add coin at index num_coins\r\n+   - Increment num_coins\r\n+4. Return 0 on success, -1 on failure\r\n+\r\n+### 4.6. locker_index_remove_coins(an, coins_array, num_coins)\r\n+**Purpose**: Remove coins from a standard locker.\r\n+\r\n+**Logic**:\r\n+1. Acquire locker_mtx\r\n+2. Find index entry with matching AN\r\n+3. If not found, release lock and return\r\n+4. For each coin to remove:\r\n+   - Linear search through entry's coins array\r\n+   - If found, shift remaining elements left to remove gap\r\n+   - Decrement num_coins\r\n+5. If num_coins reaches 0:\r\n+   - Free coins array\r\n+   - Free index entry\r\n+   - Set index slot to NULL\r\n+6. Release locker_mtx\r\n+\r\n+### 4.7. trade_locker_index_remove_coins(an, coins_array, num_coins)\r\n+**Logic**: Same as 4.6 but uses trade_locker_mtx and trade_locker_index\r\n+\r\n+### 4.8. Query Functions\r\n+\r\n+#### get_coins_from_index(an) / get_coins_from_trade_index(an)\r\n+**Returns**: Pointer to Index Entry Object or NULL\r\n+\r\n+**Logic**:\r\n+1. Acquire appropriate lock\r\n+2. Linear search through index for matching AN (compare all 16 bytes)\r\n+3. Store result pointer\r\n+4. Release lock\r\n+5. Return result\r\n+\r\n+#### get_coins_from_index_by_prefix(an_prefix)\r\n+**Purpose**: Find entry matching first 5 bytes of AN (for encryption scenarios)\r\n+\r\n+**Logic**: Same as above but compare only first 5 bytes\r\n+\r\n+#### load_coins_from_trade_index(coin_type, max_results, output_array)\r\n+**Purpose**: Get up to max_results trade lockers of specified type\r\n+\r\n+**Logic**:\r\n+1. Acquire trade_locker_mtx\r\n+2. Iterate through trade_locker_index\r\n+3. If entry's AN[13] matches coin_type, add to output_array\r\n+4. Stop when max_results reached or end of index\r\n+5. Release lock\r\n+6. Return actual count found\r\n+\r\n+#### get_entry_from_trade_index(coin_type, amount, price)\r\n+**Purpose**: Find specific trade locker by criteria\r\n+\r\n+**Logic**:\r\n+1. Acquire trade_locker_mtx\r\n+2. For each entry in trade_locker_index:\r\n+   - Check if AN[13] matches coin_type\r\n+   - Extract price from AN[9:12] (4 bytes, big-endian)\r\n+   - Calculate total value by summing coin values\r\n+   - If all match, store result and break\r\n+3. Release lock\r\n+4. Return result\r\n+\r\n+### 4.9. Utility Functions\r\n+\r\n+#### calc_coins_in_trade_locker(index_entry)\r\n+**Purpose**: Calculate total value of coins in a trade locker\r\n+\r\n+**Logic**:\r\n+1. Initialize sum to 0\r\n+2. For each coin in entry:\r\n+   - Add coin_value(coin.denomination, coin.sn) to sum\r\n+3. Return sum\r\n+\r\n+#### free_index() / free_trade_index()\r\n+**Purpose**: Clean up all index entries (mutex must be held by caller)\r\n+\r\n+**Logic**:\r\n+1. For each non-NULL entry in index:\r\n+   - Free coins array\r\n+   - Free index entry\r\n+   - Set slot to NULL\r\n+2. Log number of entries freed\r\n+\r\n+## 5. Error Handling\r\n+\r\n+### 5.1 Memory Allocation Failures\r\n+- All malloc/realloc calls must be checked\r\n+- On failure: Log error with context, clean up partial allocations, return error code\r\n+- Never leave dangling pointers or partially initialized structures\r\n+\r\n+### 5.2 Database Access Errors\r\n+- If page retrieval fails during initial build: Log error, skip that page, continue\r\n+- System should be resilient to partial data\r\n+\r\n+### 5.3 Concurrency Safety\r\n+- Lock acquisition order must be consistent to prevent deadlocks\r\n+- When both locks needed: Always acquire in order (locker_mtx, then trade_locker_mtx)\r\n+- All lock acquisitions must have corresponding releases on all code paths\r\n+\r\n+### 5.4 Input Validation\r\n+- Validate denomination is within valid range\r\n+- Validate coin type for trade operations\r\n+- Check array bounds before access\r\n+- Validate AN format for locker type\r\n+\r\n+## 6. Performance Considerations\r\n+\r\n+### 6.1 Memory Management\r\n+- Pre-allocate in chunks of PREALLOCATE_COINS to reduce reallocation frequency\r\n+- Use array-based storage for O(1) indexed access where possible\r\n+\r\n+### 6.2 Search Optimization\r\n+- Linear search is acceptable for MAX_LOCKER_RECORDS = 10000\r\n+- Consider upgrading to hash table if performance becomes an issue\r\n+\r\n+### 6.3 Lock Granularity\r\n+- Separate locks for standard and trade indices allow concurrent operations\r\n+- Hold locks for minimum time necessary\r\n+- Avoid nested function calls while holding locks\r\n+\r\n+## 7. Thread Safety Contract\r\n+- All public functions are thread-safe\r\n+- Internal functions ending in _internal require caller to hold appropriate lock\r\n+- No function should return while holding a lock\r\n+- Index Entry Objects returned by query functions must not be modified by callers\n\\ No newline at end of file\n"
                },
                {
                    "date": 1751960007303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -279,9 +279,9 @@\n \r\n /////////////////////////////////////////////////////////////\r\n \r\n \r\n-# Language-Agnostic Specification: Locker Index Implementation\r\n+#  Specification: Locker Index Implementation\r\n \r\n ## 1. Module Purpose\r\n This module provides the concrete implementation for the in-memory Locker Index. It is responsible for the one-time initial build of the index and for providing thread-safe functions for incremental updates for both standard and trade lockers.\r\n \r\n"
                }
            ],
            "date": 1751955135842,
            "name": "Commit-0",
            "content": "Language-Agnostic Specification: Locker Index Implementation\r\n1. Module Purpose\r\nThis module provides the concrete implementation for the in-memory Locker Index. It is responsible for the one-time initial build of the index and for providing thread-safe functions for incremental updates for both standard and trade lockers.\r\n2. Data Model Summary\r\n2.1 Core Data Structures\r\n\r\nLocker Indices: Two separate, global, thread-safe collections (array/map) must be maintained:\r\n\r\nlocker_index: Array of pointers to Index Entry Objects (size: MAX_LOCKER_RECORDS = 10000)\r\ntrade_locker_index: Array of pointers to Index Entry Objects (size: MAX_LOCKER_RECORDS = 10000)\r\n\r\n\r\nIndex Entry Object:\r\n- an: 16-byte array (Authenticity Number)\r\n- coins: Dynamic array of Coin objects\r\n- num_coins: Integer count of coins in the array\r\n\r\nCoin Object:\r\n- denomination: 8-bit signed integer (valid range: MIN_DENOMINATION to MAX_DENOMINATION)\r\n- sn: 32-bit unsigned integer (serial number)\r\n\r\n\r\n2.2 Locking Mechanism\r\n\r\nTwo separate mutexes:\r\n\r\nlocker_mtx: Protects the standard locker index\r\ntrade_locker_mtx: Protects the trade locker index\r\n\r\n\r\n\r\n2.3 Constants\r\n\r\nPREALLOCATE_COINS: 100 (initial allocation size for coins array)\r\nRECORDS_PER_PAGE: Number of coin records per database page\r\nTOTAL_PAGES: Total number of pages per denomination\r\nMIN_DENOMINATION, MAX_DENOMINATION: Valid denomination range\r\n\r\n3. Architectural Requirements\r\n\r\nOne-Time Build: The indices must be fully populated from the primary database on disk only once when the server starts.\r\nNo Background Thread: There should be no periodic rebuilding thread.\r\nIncremental Updates: All modifications after startup must be handled incrementally.\r\nConcurrency: Thread-safe operations using fine-grained locking per index type.\r\nMemory Management: Dynamic allocation with pre-allocation strategy for performance.\r\n\r\n4. Core Logic and Implementation Details\r\n4.1. initialize_locker_index()\r\nPurpose: Initialize the index system at server startup.\r\nLogic:\r\n\r\nInitialize both index arrays to NULL pointers\r\nInitialize both mutexes (locker_mtx, trade_locker_mtx)\r\nCall build_initial_locker_indices()\r\nReturn 0 on success, -1 on failure\r\n\r\nError Handling: Log and return error if mutex initialization fails.\r\n4.2. build_initial_locker_indices()\r\nPurpose: One-time build of indices from disk database.\r\nLogic:\r\n\r\nAcquire both locks (locker_mtx and trade_locker_mtx)\r\nClear any existing index entries (call free_index() and free_trade_index())\r\nFor each denomination (MIN_DENOMINATION to MAX_DENOMINATION):\r\n\r\nFor each page (0 to TOTAL_PAGES-1):\r\n\r\nLock and retrieve the page from database\r\nFor each record in page (0 to RECORDS_PER_PAGE-1):\r\n\r\nCalculate serial number: sn = page_number * RECORDS_PER_PAGE + record_index\r\nExtract AN from record (offset: record_index * 17, length: 16 bytes)\r\nCheck AN format:\r\n\r\nIf bytes 12-15 are all 0xFF: Add to standard locker index\r\nIf byte 13 is valid trade type AND bytes 14-15 are 0xEE: Add to trade index\r\n\r\n\r\n\r\n\r\nUnlock the page\r\n\r\n\r\n\r\n\r\nRelease both locks\r\n\r\nTrade Type Validation: Valid types are SALE_TYPE_CC, SALE_TYPE_BTC, SALE_TYPE_XMR\r\n4.3. locker_index_add_coins(an, coins_array, num_coins)\r\nPurpose: Add coins to a standard locker.\r\nParameters:\r\n\r\nan: 16-byte array (locker identifier)\r\ncoins_array: Array of Coin objects to add\r\nnum_coins: Number of coins to add\r\n\r\nLogic:\r\n\r\nAcquire locker_mtx\r\nFor each coin in coins_array:\r\n\r\nCall internal add_index_entry_internal(coin.denomination, coin.sn, an)\r\n\r\n\r\nRelease locker_mtx\r\n\r\n4.4. trade_locker_index_add_coins(an, coins_array, num_coins)\r\nPurpose: Add coins to a trade locker.\r\nLogic: Same as 4.3 but uses trade_locker_mtx and add_trade_index_entry_internal()\r\n4.5. Internal add_index_entry_internal(denomination, sn, an)\r\nPurpose: Add a single coin to an index entry (mutex must be held by caller).\r\nLogic:\r\n\r\nSearch index array for matching AN or first NULL slot\r\nIf new entry (NULL slot found):\r\n\r\nAllocate new Index Entry Object\r\nAllocate coins array with PREALLOCATE_COINS capacity\r\nSet num_coins = 1\r\nCopy AN and add first coin\r\n\r\n\r\nIf existing entry found:\r\n\r\nCheck if reallocation needed: (num_coins % PREALLOCATE_COINS) == 0\r\nIf yes:\r\n\r\nCalculate new size: ((num_coins / PREALLOCATE_COINS) + 1) * PREALLOCATE_COINS\r\nAllocate new array, copy old data, free old array\r\n\r\n\r\nAdd coin at index num_coins\r\nIncrement num_coins\r\n\r\n\r\nReturn 0 on success, -1 on failure\r\n\r\n4.6. locker_index_remove_coins(an, coins_array, num_coins)\r\nPurpose: Remove coins from a standard locker.\r\nLogic:\r\n\r\nAcquire locker_mtx\r\nFind index entry with matching AN\r\nIf not found, release lock and return\r\nFor each coin to remove:\r\n\r\nLinear search through entry's coins array\r\nIf found, shift remaining elements left to remove gap\r\nDecrement num_coins\r\n\r\n\r\nIf num_coins reaches 0:\r\n\r\nFree coins array\r\nFree index entry\r\nSet index slot to NULL\r\n\r\n\r\nRelease locker_mtx\r\n\r\n4.7. trade_locker_index_remove_coins(an, coins_array, num_coins)\r\nLogic: Same as 4.6 but uses trade_locker_mtx and trade_locker_index\r\n4.8. Query Functions\r\nget_coins_from_index(an) / get_coins_from_trade_index(an)\r\nReturns: Pointer to Index Entry Object or NULL\r\nLogic:\r\n\r\nAcquire appropriate lock\r\nLinear search through index for matching AN (compare all 16 bytes)\r\nStore result pointer\r\nRelease lock\r\nReturn result\r\n\r\nget_coins_from_index_by_prefix(an_prefix)\r\nPurpose: Find entry matching first 5 bytes of AN (for encryption scenarios)\r\nLogic: Same as above but compare only first 5 bytes\r\nload_coins_from_trade_index(coin_type, max_results, output_array)\r\nPurpose: Get up to max_results trade lockers of specified type\r\nLogic:\r\n\r\nAcquire trade_locker_mtx\r\nIterate through trade_locker_index\r\nIf entry's AN[13] matches coin_type, add to output_array\r\nStop when max_results reached or end of index\r\nRelease lock\r\nReturn actual count found\r\n\r\nget_entry_from_trade_index(coin_type, amount, price)\r\nPurpose: Find specific trade locker by criteria\r\nLogic:\r\n\r\nAcquire trade_locker_mtx\r\nFor each entry in trade_locker_index:\r\n\r\nCheck if AN[13] matches coin_type\r\nExtract price from AN[9:12] (4 bytes, big-endian)\r\nCalculate total value by summing coin values\r\nIf all match, store result and break\r\n\r\n\r\nRelease lock\r\nReturn result\r\n\r\n4.9. Utility Functions\r\ncalc_coins_in_trade_locker(index_entry)\r\nPurpose: Calculate total value of coins in a trade locker\r\nLogic:\r\n\r\nInitialize sum to 0\r\nFor each coin in entry:\r\n\r\nAdd coin_value(coin.denomination, coin.sn) to sum\r\n\r\n\r\nReturn sum\r\n\r\nfree_index() / free_trade_index()\r\nPurpose: Clean up all index entries (mutex must be held by caller)\r\nLogic:\r\n\r\nFor each non-NULL entry in index:\r\n\r\nFree coins array\r\nFree index entry\r\nSet slot to NULL\r\n\r\n\r\nLog number of entries freed\r\n\r\n5. Error Handling\r\n5.1 Memory Allocation Failures\r\n\r\nAll malloc/realloc calls must be checked\r\nOn failure: Log error with context, clean up partial allocations, return error code\r\nNever leave dangling pointers or partially initialized structures\r\n\r\n5.2 Database Access Errors\r\n\r\nIf page retrieval fails during initial build: Log error, skip that page, continue\r\nSystem should be resilient to partial data\r\n\r\n5.3 Concurrency Safety\r\n\r\nLock acquisition order must be consistent to prevent deadlocks\r\nWhen both locks needed: Always acquire in order (locker_mtx, then trade_locker_mtx)\r\nAll lock acquisitions must have corresponding releases on all code paths\r\n\r\n5.4 Input Validation\r\n\r\nValidate denomination is within valid range\r\nValidate coin type for trade operations\r\nCheck array bounds before access\r\nValidate AN format for locker type\r\n\r\n6. Performance Considerations\r\n6.1 Memory Management\r\n\r\nPre-allocate in chunks of PREALLOCATE_COINS to reduce reallocation frequency\r\nUse array-based storage for O(1) indexed access where possible\r\n\r\n6.2 Search Optimization\r\n\r\nLinear search is acceptable for MAX_LOCKER_RECORDS = 10000\r\nConsider upgrading to hash table if performance becomes an issue\r\n\r\n6.3 Lock Granularity\r\n\r\nSeparate locks for standard and trade indices allow concurrent operations\r\nHold locks for minimum time necessary\r\nAvoid nested function calls while holding locks\r\n\r\n7. Thread Safety Contract\r\n\r\nAll public functions are thread-safe\r\nInternal functions ending in _internal require caller to hold appropriate lock\r\nNo function should return while holding a lock\r\nIndex Entry Objects returned by query functions must not be modified by callers"
        }
    ]
}