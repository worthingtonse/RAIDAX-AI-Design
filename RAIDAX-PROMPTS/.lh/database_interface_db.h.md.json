{
    "sourceFile": "database_interface_db.h.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1751889453816,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1751958681277,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,5 +34,381 @@\n \r\n 4. Architectural Notes\r\n This design assumes all pages are loaded into RAM and modified in-place. It is not designed for shared-nothing or distributed memory architectures.\r\n \r\n-The interface abstracts the persistence mechanism, allowing the implementation to use any thread-safe queue and signaling primitive (e.g., condition variables).\n\\ No newline at end of file\n+The interface abstracts the persistence mechanism, allowing the implementation to use any thread-safe queue and signaling primitive (e.g., condition variables).\r\n+\r\n+\r\n+\r\n+\r\n+/////////////////\r\n+\r\n+\r\n+# Language-Agnostic Specification: CloudCoin Database Header Interface\r\n+\r\n+## 1. Module Purpose\r\n+This specification defines the public interface for the CloudCoin database layer. It establishes the data structures, constants, function signatures, and type definitions required for implementing a thread-safe, high-performance coin database system.\r\n+\r\n+## 2. System Constants and Configuration\r\n+\r\n+### 2.1 Core System Parameters\r\n+```\r\n+TOTAL_DENOMINATIONS = 15\r\n+TOTAL_PAGES = 1000\r\n+RECORDS_PER_PAGE = 1024\r\n+RECORD_SIZE = 17 bytes\r\n+DENOMINATION_OFFSET = 8\r\n+RESERVED_PAGE_RELEASE_SECONDS = 16\r\n+PAGES_IN_RAM = TOTAL_PAGES (all pages kept in memory)\r\n+```\r\n+\r\n+### 2.2 Denomination Enumeration\r\n+The system must support exactly 15 denominations with the following mapping:\r\n+\r\n+| Symbolic Name    | Integer Value | Decimal Representation |\r\n+|------------------|---------------|------------------------|\r\n+| DEN_0_00000001   | -8           | 0.00000001            |\r\n+| DEN_0_0000001    | -7           | 0.0000001             |\r\n+| DEN_0_000001     | -6           | 0.000001              |\r\n+| DEN_0_00001      | -5           | 0.00001               |\r\n+| DEN_0_0001       | -4           | 0.0001                |\r\n+| DEN_0_001        | -3           | 0.001                 |\r\n+| DEN_0_01         | -2           | 0.01                  |\r\n+| DEN_0_1          | -1           | 0.1                   |\r\n+| DEN_1            | 0            | 1                     |\r\n+| DEN_10           | 1            | 10                    |\r\n+| DEN_100          | 2            | 100                   |\r\n+| DEN_1000         | 3            | 1000                  |\r\n+| DEN_10000        | 4            | 10000                 |\r\n+| DEN_100000       | 5            | 100000                |\r\n+| DEN_1000000      | 6            | 1000000               |\r\n+\r\n+### 2.3 Boundary Constants\r\n+```\r\n+MIN_DENOMINATION = -8 (DEN_0_00000001)\r\n+MAX_DENOMINATION = 6  (DEN_1000000)\r\n+```\r\n+\r\n+## 3. Core Data Structures\r\n+\r\n+### 3.1 Page Structure Definition\r\n+The `page_object` structure represents a single page of coin data and must contain the following fields in this exact logical order:\r\n+\r\n+```\r\n+page_object:\r\n+    data: byte_array[RECORDS_PER_PAGE × 17]     // 17,408 bytes total\r\n+    reserved_at: timestamp_type                  // Platform-specific time type\r\n+    reserved_by: unsigned_32bit_integer         // Session ID (0 = not reserved)\r\n+    mutex: thread_mutex_type                    // Platform-specific mutex\r\n+    in_dirty_queue: integer                     // Flag: 0 = not queued, 1 = queued\r\n+    denomination: signed_8bit_integer           // Range: -8 to 6 (debugging field)\r\n+    page_number: unsigned_16bit_integer         // Range: 0 to 999 (debugging field)\r\n+```\r\n+\r\n+### 3.2 Field Specifications\r\n+\r\n+#### 3.2.1 Data Field\r\n+- **Size**: RECORDS_PER_PAGE × 17 bytes = 1024 × 17 = 17,408 bytes\r\n+- **Layout**: Each record is exactly 17 bytes (16-byte AN + 1-byte MFS)\r\n+- **Access**: Direct byte array indexing for performance\r\n+\r\n+#### 3.2.2 Reservation Fields\r\n+- **reserved_at**: Platform-specific timestamp (time_t equivalent)\r\n+  - Set to current time when page is reserved\r\n+  - Used for timeout calculations\r\n+- **reserved_by**: 32-bit session identifier\r\n+  - 0 indicates page is not reserved\r\n+  - Non-zero indicates active reservation\r\n+\r\n+#### 3.2.3 Synchronization Fields\r\n+- **mutex**: Platform-specific thread synchronization primitive\r\n+  - Must support lock/unlock operations\r\n+  - Required for thread-safe page access\r\n+- **in_dirty_queue**: Integer flag for persistence queue management\r\n+  - 0 = page not in dirty queue\r\n+  - 1 = page is queued for persistence\r\n+  - Prevents duplicate queue entries\r\n+\r\n+#### 3.2.4 Debug Fields\r\n+- **denomination**: Signed 8-bit integer storing the page's denomination\r\n+  - Range: -8 to 6\r\n+  - Used for debugging and validation\r\n+  - Can be removed if memory optimization is critical\r\n+- **page_number**: Unsigned 16-bit integer storing the page index\r\n+  - Range: 0 to 999\r\n+  - Used for debugging and validation\r\n+  - Can be removed if memory optimization is critical\r\n+\r\n+## 4. Public Function Interface\r\n+\r\n+### 4.1 Initialization Functions\r\n+\r\n+#### 4.1.1 init_db()\r\n+```\r\n+Function: init_db\r\n+Parameters: none\r\n+Returns: integer (0 = success, negative = error)\r\n+Purpose: Initialize the entire database system\r\n+```\r\n+- Creates directory structure\r\n+- Initializes all pages\r\n+- Loads pages into memory\r\n+- Starts background threads\r\n+\r\n+#### 4.1.2 init_page(seed, denomination, page_number)\r\n+```\r\n+Function: init_page\r\n+Parameters: \r\n+    seed: integer (random seed for AN generation)\r\n+    denomination: signed_8bit_integer (range: -8 to 6)\r\n+    page_number: integer (range: 0 to 999)\r\n+Returns: integer (0 = success, negative = error)\r\n+Purpose: Initialize a single page file if it doesn't exist\r\n+```\r\n+\r\n+#### 4.1.3 load_pages()\r\n+```\r\n+Function: load_pages\r\n+Parameters: none\r\n+Returns: integer (0 = success, negative = error)\r\n+Purpose: Load all page files from disk into memory\r\n+```\r\n+\r\n+### 4.2 Page Access Functions\r\n+\r\n+#### 4.2.1 get_page(denomination, page_number)\r\n+```\r\n+Function: get_page\r\n+Parameters:\r\n+    denomination: signed_8bit_integer (range: -8 to 6)\r\n+    page_number: integer (range: 0 to 999)\r\n+Returns: pointer to page_object (NULL if invalid)\r\n+Purpose: Get page reference without locking\r\n+```\r\n+\r\n+#### 4.2.2 get_page_lock(denomination, page_number)\r\n+```\r\n+Function: get_page_lock\r\n+Parameters:\r\n+    denomination: signed_8bit_integer (range: -8 to 6)\r\n+    page_number: integer (range: 0 to 999)\r\n+Returns: pointer to page_object (NULL if invalid)\r\n+Purpose: Get page reference and acquire its mutex\r\n+```\r\n+\r\n+#### 4.2.3 unlock_page(page_pointer)\r\n+```\r\n+Function: unlock_page\r\n+Parameters:\r\n+    page_pointer: pointer to page_object\r\n+Returns: void\r\n+Purpose: Release the page mutex\r\n+```\r\n+\r\n+#### 4.2.4 get_page_by_sn_lock(denomination, serial_number)\r\n+```\r\n+Function: get_page_by_sn_lock\r\n+Parameters:\r\n+    denomination: signed_8bit_integer (range: -8 to 6)\r\n+    serial_number: unsigned_32bit_integer\r\n+Returns: pointer to page_object (NULL if invalid)\r\n+Purpose: Get and lock page containing the specified serial number\r\n+Implementation: page_number = serial_number / RECORDS_PER_PAGE\r\n+```\r\n+\r\n+### 4.3 Page Reservation Functions\r\n+\r\n+#### 4.3.1 page_is_reserved(page_pointer)\r\n+```\r\n+Function: page_is_reserved\r\n+Parameters:\r\n+    page_pointer: pointer to page_object\r\n+Returns: integer (0 = not reserved, 1 = reserved)\r\n+Purpose: Check if page is currently reserved, auto-release if expired\r\n+```\r\n+\r\n+#### 4.3.2 reserve_page(page_pointer, session_id)\r\n+```\r\n+Function: reserve_page\r\n+Parameters:\r\n+    page_pointer: pointer to page_object\r\n+    session_id: unsigned_32bit_integer\r\n+Returns: void\r\n+Purpose: Reserve page for exclusive access by session\r\n+```\r\n+\r\n+#### 4.3.3 release_reserved_page(page_pointer)\r\n+```\r\n+Function: release_reserved_page\r\n+Parameters:\r\n+    page_pointer: pointer to page_object\r\n+Returns: void\r\n+Purpose: Manually release page reservation\r\n+```\r\n+\r\n+### 4.4 Persistence Functions\r\n+\r\n+#### 4.4.1 add_page_to_dirty_queue(page_pointer)\r\n+```\r\n+Function: add_page_to_dirty_queue\r\n+Parameters:\r\n+    page_pointer: pointer to page_object\r\n+Returns: void\r\n+Purpose: Queue modified page for background persistence\r\n+Prerequisites: Page mutex must be held by caller\r\n+```\r\n+\r\n+#### 4.4.2 sync_pages_thread(thread_argument)\r\n+```\r\n+Function: sync_pages_thread\r\n+Parameters:\r\n+    thread_argument: platform-specific thread parameter\r\n+Returns: platform-specific thread return type\r\n+Purpose: Background thread function for persistence operations\r\n+```\r\n+\r\n+#### 4.4.3 sync_page(page_pointer)\r\n+```\r\n+Function: sync_page\r\n+Parameters:\r\n+    page_pointer: pointer to page_object\r\n+Returns: void\r\n+Purpose: Write single page to disk immediately\r\n+```\r\n+\r\n+### 4.5 Utility Functions\r\n+\r\n+#### 4.5.1 get_den_idx(denomination)\r\n+```\r\n+Function: get_den_idx\r\n+Parameters:\r\n+    denomination: signed_8bit_integer (range: -8 to 6)\r\n+Returns: integer (array index: 0 to 14)\r\n+Purpose: Convert denomination value to array index\r\n+Implementation: return denomination + DENOMINATION_OFFSET\r\n+```\r\n+\r\n+#### 4.5.2 get_den_by_idx(index)\r\n+```\r\n+Function: get_den_by_idx\r\n+Parameters:\r\n+    index: integer (range: 0 to 14)\r\n+Returns: signed_8bit_integer (denomination: -8 to 6)\r\n+Purpose: Convert array index to denomination value\r\n+Implementation: return index - DENOMINATION_OFFSET\r\n+```\r\n+\r\n+## 5. Data Type Requirements\r\n+\r\n+### 5.1 Platform-Specific Types\r\n+Implementations must map these logical types to appropriate platform types:\r\n+\r\n+- **signed_8bit_integer**: int8_t or equivalent (-128 to 127)\r\n+- **unsigned_16bit_integer**: uint16_t or equivalent (0 to 65535)\r\n+- **unsigned_32bit_integer**: uint32_t or equivalent (0 to 4294967295)\r\n+- **timestamp_type**: time_t or equivalent platform timestamp\r\n+- **thread_mutex_type**: pthread_mutex_t or equivalent platform mutex\r\n+- **byte_array**: unsigned char array or equivalent byte storage\r\n+\r\n+### 5.2 Memory Layout Requirements\r\n+- **Alignment**: Page data should be aligned for optimal memory access\r\n+- **Packing**: No padding between data records within a page\r\n+- **Endianness**: Implementation-defined (must be consistent across system)\r\n+\r\n+## 6. Thread Safety Requirements\r\n+\r\n+### 6.1 Locking Protocol\r\n+- **Page-Level Locking**: Each page has its own mutex for fine-grained concurrency\r\n+- **Lock Ordering**: Always acquire page mutex before checking/setting in_dirty_queue\r\n+- **No Global Locks**: Avoid system-wide locking for scalability\r\n+\r\n+### 6.2 Thread-Safe Functions\r\n+All public functions must be thread-safe with the following exceptions:\r\n+- Functions returning page pointers without locking require caller synchronization\r\n+- Page modification requires holding the page mutex\r\n+\r\n+### 6.3 Synchronization Primitives Required\r\n+- **Mutex**: For page-level locking\r\n+- **Condition Variable**: For dirty queue signaling\r\n+- **Thread Creation**: For background persistence thread\r\n+\r\n+## 7. Error Handling Interface\r\n+\r\n+### 7.1 Return Code Convention\r\n+- **Success**: Return 0\r\n+- **General Error**: Return negative integer\r\n+- **Invalid Parameters**: Return -1\r\n+- **System Error**: Return platform-specific error code\r\n+- **Memory Error**: Return -ENOMEM equivalent\r\n+\r\n+### 7.2 Null Pointer Handling\r\n+- Functions returning pointers return NULL on error\r\n+- Caller must check for NULL before dereferencing\r\n+- NULL parameters to functions should be handled gracefully\r\n+\r\n+## 8. Memory Management Contract\r\n+\r\n+### 8.1 Static Allocation\r\n+- All page objects are statically allocated at startup\r\n+- No dynamic allocation/deallocation during normal operation\r\n+- Global page array: `page_object[TOTAL_DENOMINATIONS][TOTAL_PAGES]`\r\n+\r\n+### 8.2 Resource Lifecycle\r\n+- **Initialization**: All resources allocated during init_db()\r\n+- **Runtime**: No allocation/deallocation except for dirty queue nodes\r\n+- **Cleanup**: Platform-specific cleanup (not defined in this interface)\r\n+\r\n+### 8.3 Memory Footprint\r\n+- **Total Page Data**: 15 denominations × 1000 pages × 17,408 bytes ≈ 256 MB\r\n+- **Metadata Overhead**: Minimal (mutexes, flags, debug fields)\r\n+- **Queue Overhead**: Dynamic based on modification rate\r\n+\r\n+## 9. Performance Characteristics\r\n+\r\n+### 9.1 Access Patterns\r\n+- **Read Operations**: O(1) direct array access\r\n+- **Write Operations**: O(1) modification + O(1) queue insertion\r\n+- **Lock Contention**: Per-page granularity minimizes blocking\r\n+\r\n+### 9.2 Scalability Limits\r\n+- **Maximum Pages**: 1000 per denomination (fixed)\r\n+- **Maximum Denominations**: 15 (fixed)\r\n+- **Concurrent Access**: Limited by page-level lock contention\r\n+\r\n+## 10. Integration Requirements\r\n+\r\n+### 10.1 Include Dependencies\r\n+Implementations must provide or include:\r\n+- Thread synchronization primitives (mutex, condition variables)\r\n+- Standard integer types (int8_t, uint16_t, uint32_t)\r\n+- Time handling functions (time_t or equivalent)\r\n+\r\n+### 10.2 Compiler/Platform Considerations\r\n+- **Thread Safety**: Compiler must support thread-safe code generation\r\n+- **Atomic Operations**: Platform should support atomic integer operations\r\n+- **Memory Barriers**: Implementation should consider memory ordering\r\n+\r\n+## 11. Validation and Testing Interface\r\n+\r\n+### 11.1 Parameter Validation\r\n+All functions must validate:\r\n+- Denomination range (-8 to 6)\r\n+- Page number range (0 to 999)\r\n+- Non-null pointer parameters where required\r\n+\r\n+### 11.2 Debug Support\r\n+- Debug fields in page structure support runtime validation\r\n+- Error logging should include context information\r\n+- Performance metrics should be collectible\r\n+\r\n+## 12. Backwards Compatibility Notes\r\n+\r\n+### 12.1 Deprecated Features\r\n+- **is_dirty flag**: Replaced by in_dirty_queue and event-driven persistence\r\n+- **Polling sync**: Replaced by condition variable signaling\r\n+\r\n+### 12.2 Migration Considerations\r\n+- File format remains compatible with previous versions\r\n+- API changes are additive (new queue-based functions)\r\n+- Thread safety improvements are transparent to callers\r\n+\r\n+This header specification provides complete interface definition for implementing a CloudCoin database system. Developers should implement all specified functions while adapting data types and synchronization primitives to their target platform.\n\\ No newline at end of file\n"
                },
                {
                    "date": 1751960021968,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,9 @@\n \r\n /////////////////\r\n \r\n \r\n-# Language-Agnostic Specification: CloudCoin Database Header Interface\r\n+# Specification: CloudCoin Database Header Interface\r\n \r\n ## 1. Module Purpose\r\n This specification defines the public interface for the CloudCoin database layer. It establishes the data structures, constants, function signatures, and type definitions required for implementing a thread-safe, high-performance coin database system.\r\n \r\n"
                }
            ],
            "date": 1751889453816,
            "name": "Commit-0",
            "content": "Language-Agnostic Specification: Database Interface\r\n1. Module Purpose\r\nThis module defines the public interface and data structures for the in-memory database layer. It is responsible for managing the state of all \"coins\" and their corresponding data pages. The design must support high-performance, concurrent access and an efficient, event-driven persistence mechanism.\r\n\r\n2. Data Models\r\n2.1. Page Object\r\nA structure representing a single \"page\" of coin data held in memory.\r\n\r\ndata: A raw byte array of a fixed size (RECORDS_PER_PAGE × 17 bytes) containing authenticity numbers (ANs) and other metadata.\r\n\r\ndenomination: An integer representing the page's denomination class.\r\n\r\npage_number: An integer identifier for the page.\r\n\r\nconcurrency_primitive: A lock or mutex to ensure thread-safe access to the page's data.\r\n\r\nin_dirty_queue: A boolean flag to prevent the same page from being added to the persistence queue multiple times before it has been written to disk.\r\n\r\nreservation_metadata: Fields to track temporary client reservations (e.g., reserved_by_id, reservation_timestamp).\r\n\r\n2.2. Dirty Page Queue\r\nA thread-safe, first-in, first-out (FIFO) queue that holds references to Page Object instances that have been modified and need to be written to disk.\r\n\r\n3. Required Functions\r\ninitialize_database(): Initializes the database system, including creating directories, loading all page data from disk into memory, and launching the background persistence thread.\r\n\r\nget_page_and_lock(denomination, page_number): Retrieves a specific page from the in-memory store and acquires its lock for exclusive access. Returns a handle to the locked page object.\r\n\r\nunlock_page(page_object): Releases the lock on a page object.\r\n\r\nadd_page_to_dirty_queue(page_object): A thread-safe, non-blocking function that adds a modified page to the persistence queue and signals the persistence thread.\r\n\r\nstart_persistence_thread(): Launches the background thread responsible for writing dirty pages to disk.\r\n\r\n4. Architectural Notes\r\nThis design assumes all pages are loaded into RAM and modified in-place. It is not designed for shared-nothing or distributed memory architectures.\r\n\r\nThe interface abstracts the persistence mechanism, allowing the implementation to use any thread-safe queue and signaling primitive (e.g., condition variables)."
        }
    ]
}