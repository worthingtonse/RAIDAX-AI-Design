{
    "sourceFile": "key_exhange_command_implementation_cmd_key_exchange.c.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1751988459785,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1751988459785,
            "name": "Commit-0",
            "content": "#  Specification: Key Exchange Commands Implementation\r\n\r\n## 1. Module Purpose\r\nThis module implements secure key exchange and cryptographic key management commands for the CloudCoin RAIDA system. It provides cryptographically secure key generation, coin-based key encryption/decryption, RAIDA server key management, and chat system key storage with enhanced security features including secure random key generation and nonce-based encryption.\r\n\r\n## 2. System Architecture Overview\r\n\r\n### 2.1 Core Components\r\n- **Secure Key Generation**: Cryptographically random session key creation\r\n- **Coin-Based Encryption**: Using coin ANs as public keys for key exchange\r\n- **RAIDA Key Management**: Multi-server encrypted key distribution and decryption\r\n- **Chat Key Storage**: Filesystem-based key storage for communication systems\r\n- **Enhanced Encryption**: Nonce-based CTR mode encryption for improved security\r\n\r\n### 2.2 Security Model\r\n- **Cryptographic Randomness**: Secure random number generation for session keys\r\n- **Coin-Based Authentication**: Coin ANs serve as cryptographic identifiers\r\n- **Multi-Server Distribution**: Keys distributed across multiple RAIDA servers\r\n- **Filesystem Security**: Secure key file storage with appropriate permissions\r\n\r\n## 3. System Constants and Configuration\r\n\r\n### 3.1 Key Management Constants\r\n```\r\nSESSION_KEY_SIZE = 16 bytes            // Standard session key size\r\nRAIDA_KEY_RECORD_SIZE = 26 bytes       // Per-coin record in RAIDA key operations\r\nENCRYPTION_COIN_FILE_SIZE = 440 bytes  // Standard encryption coin file size\r\nENCRYPTION_COIN_DATA_SIZE = 400 bytes  // Actual key data size (25 RAIDA * 16 bytes)\r\nENCRYPTION_COIN_OFFSET = 40 bytes      // Offset to key data in coin file\r\nMAX_KEY_SEGMENT_SIZE = 127 bytes       // Maximum key segment length\r\nCHAT_KEY_BUFFER_SIZE = 512 bytes       // Buffer size for chat key operations\r\n```\r\n\r\n### 3.2 Request Format Constants\r\n```\r\nENCRYPT_KEY_SIZE = 23 bytes            // 16 challenge + 5 coin + 2 EOF\r\nPOST_KEY_SIZE = 185 bytes              // 16 challenge + 165 key data + 4 control + 2 EOF\r\nGET_KEY_SIZE = 55 bytes                // 16 challenge + 37 identifier + 2 EOF\r\nDECRYPT_KEY_MIN_SIZE = 49 bytes        // 16 challenge + 5 coin + 26 key record + 2 EOF\r\n```\r\n\r\n### 3.3 File System Constants\r\n```\r\nCOIN_FILE_PERMISSIONS = 0640           // Read/write owner, read group\r\nKEY_FILE_PERMISSIONS = 0640            // Read/write owner, read group\r\nCOIN_FILE_PATH = \"{config.cwd}/coins/{den:02x}.{sn}.bin\"\r\nKEY_FILE_PATH = \"{config.cwd}/Keys/{16-byte-hex-identifier}\"\r\n```\r\n\r\n## 4. Core Command Implementations\r\n\r\n### 4.1. cmd_encrypt_key\r\n**Purpose**: Generates cryptographically secure session key and encrypts it for recipient.\r\n\r\n**Request Format**:\r\n```\r\n[16 bytes Challenge Header]\r\n[1 byte Recipient Denomination]\r\n[4 bytes Recipient Serial Number]\r\n[2 bytes EOF trailer]\r\nTotal size: exactly 23 bytes\r\n```\r\n\r\n**Enhanced Security Processing**:\r\n1. **Validation**: Verify request size equals 23 bytes exactly\r\n2. **Recipient Key Retrieval**:\r\n   - Extract recipient denomination and serial number\r\n   - Lock database page containing recipient coin\r\n   - Copy recipient's AN (16 bytes) from coin record\r\n   - Unlock database page\r\n3. **Secure Key Generation**:\r\n   - **Generate cryptographically random 16-byte session key** using generate_random_bytes()\r\n   - Verify successful random generation (return ERROR_INTERNAL on failure)\r\n4. **Key Encryption**:\r\n   - Allocate 16-byte output buffer\r\n   - **Security Note**: XOR session key with recipient AN (placeholder for asymmetric encryption)\r\n   - In production systems, use proper asymmetric encryption (RSA, ECC, etc.)\r\n5. **Response Preparation**:\r\n   - Set output size to 16 bytes\r\n   - Set command status to NO_ERROR\r\n\r\n**Security Improvements**:\r\n- Replaced predictable key generation with cryptographically secure random generation\r\n- Each key generation produces unique, unpredictable session keys\r\n- Foundation for proper asymmetric encryption implementation\r\n\r\n### 4.2. cmd_decrypt_raida_key\r\n**Purpose**: Decrypts keys received from RAIDA servers and updates coin data.\r\n\r\n**Request Format**:\r\n```\r\n[16 bytes Challenge Header]\r\n[1 byte Decryption Coin Denomination]\r\n[4 bytes Decryption Coin Serial Number]\r\n[26 bytes per key record: 2 coin + split + RAIDA + shard + DN + 4 SN + 16 key]\r\n[2 bytes EOF trailer]\r\nMinimum size: 49 bytes (16 + 5 + 26 + 2)\r\n```\r\n\r\n**Processing Logic**:\r\n1. **Request Validation**:\r\n   - Verify minimum size of 49 bytes\r\n   - Calculate number of key records: (body_size - 23) / 26\r\n   - Verify data length is divisible by 26\r\n\r\n2. **Decryption Coin Loading**:\r\n   - Extract decryption coin denomination and serial number\r\n   - Load encryption coin data using load_my_enc_coin()\r\n   - Retrieve 400 bytes of RAIDA key data (25 servers × 16 bytes each)\r\n\r\n3. **Key Record Processing**:\r\n   - For each 26-byte key record:\r\n     - Extract split_id, RAIDA_address, denomination, serial_number, encrypted_key\r\n     - Validate RAIDA address (must be 0-24)\r\n     - Validate split_id (must be 0 or 1)\r\n     - Select appropriate RAIDA key from loaded data (offset = RAIDA_address × 16)\r\n     - **Use request_nonce for decryption** (enhanced security)\r\n     - Decrypt 16-byte key using crypt_ctr with RAIDA key and request_nonce\r\n     - Validate decrypted key format (byte 15 must be 0xff)\r\n     - Extract and verify decrypted coin denomination and serial number\r\n     - Update coin database with decrypted key data\r\n\r\n4. **Database Updates**:\r\n   - Lock database page for target coin\r\n   - Copy 8 bytes of decrypted key to appropriate offset (split_id × 8)\r\n   - Set MFS byte to current modification sequence\r\n   - Add page to dirty queue for persistence\r\n   - Unlock database page\r\n\r\n5. **Response Generation**:\r\n   - Allocate response buffer (1 byte per key record)\r\n   - Set success bit (0x1) for successfully processed keys\r\n   - Set failure bit (0x0) for failed key processing\r\n   - Return STATUS_SUCCESS with bitmap response\r\n\r\n**Enhanced Security Features**:\r\n- Uses request_nonce for CTR mode decryption\r\n- Comprehensive validation of all key record components\r\n- Secure handling of multi-server key distribution\r\n\r\n### 4.3. load_my_enc_coin(denomination, serial_number, buffer)\r\n**Purpose**: Utility function to load encryption coin data from filesystem.\r\n\r\n**Parameters**:\r\n- denomination: 8-bit signed integer for coin denomination\r\n- serial_number: 32-bit unsigned integer for coin serial number\r\n- buffer: pointer to 400-byte output buffer for key data\r\n\r\n**Processing Logic**:\r\n1. **File Path Construction**: Build path as \"{config.cwd}/coins/{den:02x}.{sn}.bin\"\r\n2. **File Access**: Open file in read-only mode\r\n3. **File Reading**: Read exactly 440 bytes from file\r\n4. **Validation**:\r\n   - Verify file size equals 440 bytes\r\n   - Extract coin_id from bytes 2-3\r\n   - Verify coin_id matches system configuration\r\n5. **Data Extraction**: Copy 400 bytes from offset 40 to output buffer\r\n6. **Cleanup**: Close file descriptor\r\n\r\n**Return Values**:\r\n- 0: Success\r\n- -1: File access error, size validation error, or coin_id mismatch\r\n\r\n### 4.4. cmd_post_key\r\n**Purpose**: Stores cryptographic key segments for chat system.\r\n\r\n**Request Format**:\r\n```\r\n[16 bytes Challenge Header]\r\n[16 bytes Key Identifier]\r\n[128 bytes Key Data]\r\n[1 byte Denomination]\r\n[4 bytes Serial Number]\r\n[1 byte Key Start Position]\r\n[1 byte Key Length]\r\n[2 bytes EOF trailer]\r\nTotal size: exactly 185 bytes\r\n```\r\n\r\n**Processing Logic**:\r\n1. **Request Validation**: Verify request size equals 185 bytes exactly\r\n2. **Parameter Extraction**:\r\n   - Key identifier (16 bytes from offset 0)\r\n   - Denomination and serial number (5 bytes from offset 32)\r\n   - Key start position and length (2 bytes from offset 165-166)\r\n3. **Key Segment Validation**: Verify key_start + key_length <= 127\r\n4. **File Path Generation**: Create hex string path from 16-byte identifier\r\n5. **Key Storage**:\r\n   - Create key file with 0640 permissions\r\n   - Write denomination (1 byte)\r\n   - Write serial number (4 bytes)\r\n   - Write key segment data (key_length bytes from offset 37 + key_start)\r\n6. **Verification**: Ensure all data written successfully\r\n\r\n**File Format**:\r\n- Byte 0: Denomination\r\n- Bytes 1-4: Serial number\r\n- Bytes 5+: Key segment data\r\n\r\n### 4.5. cmd_get_key\r\n**Purpose**: Retrieves stored cryptographic keys for chat system.\r\n\r\n**Request Format**:\r\n```\r\n[16 bytes Challenge Header]\r\n[16 bytes Key Identifier]\r\n[21 bytes Additional Data]\r\n[2 bytes EOF trailer]\r\nTotal size: exactly 55 bytes\r\n```\r\n\r\n**Processing Logic**:\r\n1. **Request Validation**: Verify request size equals 55 bytes exactly\r\n2. **Key Identifier Extraction**: Get 16-byte identifier from request\r\n3. **File Path Generation**: Create hex string path from identifier\r\n4. **Key Retrieval**:\r\n   - Open key file in read-only mode\r\n   - Read up to 512 bytes from file\r\n   - Handle file access errors gracefully\r\n5. **Response Preparation**:\r\n   - Allocate output buffer matching file size\r\n   - Copy file contents to output buffer\r\n   - Set output size to actual bytes read\r\n   - Return STATUS_SUCCESS\r\n\r\n**Error Handling**:\r\n- File not found: Return ERROR_FILESYSTEM\r\n- Read errors: Return ERROR_FILESYSTEM\r\n- Memory allocation failure: Return ERROR_MEMORY_ALLOC\r\n\r\n### 4.6. cmd_key_alert\r\n**Purpose**: Handles key-related alerts (currently placeholder implementation).\r\n\r\n**Processing Logic**:\r\n- Immediately return STATUS_SUCCESS\r\n- No additional processing or validation\r\n- Serves as placeholder for future key alert functionality\r\n\r\n## 5. File System Integration\r\n\r\n### 5.1 Encryption Coin Files\r\n- **Location**: \"{config.cwd}/coins/{denomination:02x}.{serial_number}.bin\"\r\n- **Size**: Exactly 440 bytes\r\n- **Format**:\r\n  - Bytes 0-1: Reserved\r\n  - Bytes 2-3: Coin ID (16-bit big-endian)\r\n  - Bytes 4-39: Header/metadata\r\n  - Bytes 40-439: RAIDA key data (25 servers × 16 bytes each)\r\n\r\n### 5.2 Chat Key Files\r\n- **Location**: \"{config.cwd}/Keys/{16-byte-hex-identifier}\"\r\n- **Variable Size**: Up to 512 bytes\r\n- **Format**:\r\n  - Byte 0: Associated coin denomination\r\n  - Bytes 1-4: Associated coin serial number\r\n  - Bytes 5+: Key segment data\r\n\r\n### 5.3 File Security\r\n- **Permissions**: 0640 (read/write owner, read group only)\r\n- **Error Handling**: Comprehensive error logging with system error details\r\n- **Path Security**: Fixed directory structure prevents path traversal\r\n\r\n## 6. Cryptographic Security Features\r\n\r\n### 6.1 Enhanced Random Generation\r\n- **Secure Key Generation**: Uses generate_random_bytes() for session keys\r\n- **Cryptographic Quality**: Platform-specific secure random sources\r\n- **Error Handling**: Validates successful random generation\r\n- **Key Uniqueness**: Each session key is cryptographically unique\r\n\r\n### 6.2 Nonce-Based Encryption\r\n- **CTR Mode Enhancement**: Uses request_nonce for decryption operations\r\n- **Nonce Source**: Client-provided nonce from request header\r\n- **Security Improvement**: Prevents nonce reuse vulnerabilities\r\n- **Compatibility**: Works with enhanced protocol nonce management\r\n\r\n### 6.3 Coin-Based Cryptography\r\n- **Public Key Simulation**: Coin ANs serve as public key identifiers\r\n- **Key Distribution**: Multi-server key storage and retrieval\r\n- **Authentication**: Coin ownership proves key access rights\r\n- **Scalability**: Supports 25 RAIDA servers with individual keys\r\n\r\n## 7. Error Handling and Validation\r\n\r\n### 7.1 Request Validation\r\n- **Fixed Size Requirements**: Exact byte count validation for all commands\r\n- **Parameter Bounds**: Validate all numeric parameters within acceptable ranges\r\n- **Data Alignment**: Verify record counts match expected data sizes\r\n- **Format Validation**: Check required format markers and trailing bytes\r\n\r\n### 7.2 Cryptographic Error Handling\r\n- **Random Generation Failures**: Return ERROR_INTERNAL for secure random failures\r\n- **Decryption Validation**: Verify decrypted data meets expected format\r\n- **Key Format Checks**: Validate key structure and magic bytes\r\n- **Authentication Failures**: Handle invalid coin data gracefully\r\n\r\n### 7.3 File System Error Handling\r\n- **Access Errors**: Log specific system errors with context\r\n- **Permission Issues**: Handle file creation and access permission problems\r\n- **Size Validation**: Verify file sizes match expected values\r\n- **Resource Cleanup**: Close file descriptors on all error paths\r\n\r\n## 8. Integration Requirements\r\n\r\n### 8.1 Database Layer Integration\r\n- **Page Management**: get_page_by_sn_lock(), unlock_page() for coin access\r\n- **Data Persistence**: add_page_to_dirty_queue() for modified pages\r\n- **Record Access**: Calculate coin record offsets within pages\r\n- **MFS Management**: Update modification flag sequence appropriately\r\n\r\n### 8.2 Cryptographic Integration\r\n- **Enhanced CTR Mode**: crypt_ctr() with nonce support for encryption/decryption\r\n- **Secure Random**: generate_random_bytes() for cryptographically secure key generation\r\n- **Utility Functions**: get_sn() for serial number extraction\r\n- **MFS Generation**: get_mfs() for modification sequence numbers\r\n\r\n### 8.3 Configuration Integration\r\n- **Directory Access**: config.cwd for base directory path construction\r\n- **Coin ID Validation**: config.coin_id for encryption coin verification\r\n- **File System Setup**: Proper directory structure for coins and keys\r\n\r\n## 9. Performance Considerations\r\n\r\n### 9.1 File I/O Optimization\r\n- **Single Read Operations**: Complete file reads in single system calls\r\n- **Buffer Management**: Appropriate buffer sizes for different operations\r\n- **File Descriptor Lifecycle**: Minimize open file descriptor duration\r\n- **Error Path Efficiency**: Quick cleanup on file operation failures\r\n\r\n### 9.2 Cryptographic Performance\r\n- **Secure Random Optimization**: Efficient use of platform random sources\r\n- **Batch Processing**: Process multiple key records in single operation\r\n- **Memory Efficiency**: Appropriate buffer allocation for key operations\r\n- **CPU Optimization**: Minimize cryptographic operations per request\r\n\r\n### 9.3 Database Access Patterns\r\n- **Page Locking**: Minimize database page lock duration\r\n- **Batch Updates**: Group related database modifications\r\n- **Index Usage**: Efficient coin lookup by denomination and serial number\r\n- **Cache Efficiency**: Optimize memory access patterns for coin data\r\n\r\nThis specification provides complete implementation guidance for secure key exchange operations while remaining language-agnostic and accurately reflecting the enhanced security features and cryptographic improvements."
        }
    ]
}