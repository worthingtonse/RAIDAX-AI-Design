{
    "sourceFile": "healing_commands_cmd_healing.c.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1751970234748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1751970234748,
            "name": "Commit-0",
            "content": "# Language-Agnostic Specification: Healing Commands Implementation\r\n\r\n## 1. Module Purpose\r\nThis module implements the healing commands for the CloudCoin RAIDA system. It provides coin recovery and authentication verification through a distributed ticket-based system that enables cross-RAIDA server validation for damaged or lost coin authentication data.\r\n\r\n## 2. System Architecture Overview\r\n\r\n### 2.1 Core Components\r\n- **Ticket-Based Recovery**: Memory pool of tickets for multi-phase healing operations\r\n- **Distributed Validation**: Cross-RAIDA server communication for consensus\r\n- **Fine-Grained Locking**: Per-ticket mutex system for concurrent access\r\n- **Multi-Threaded Processing**: Parallel validation requests to RAIDA servers\r\n- **Consensus Algorithm**: Majority vote system for coin authenticity verification\r\n\r\n### 2.2 Healing Process Flow\r\n- **Ticket Creation**: Initial authentication and ticket allocation\r\n- **Ticket Validation**: Cross-server verification and claim tracking\r\n- **Coin Discovery**: Find current vs proposed authentication states\r\n- **Coin Recovery**: Consensus-based authentication number restoration\r\n\r\n## 3. System Constants and Data Structures\r\n\r\n### 3.1 Ticket System Constants\r\n```\r\nTICKET_POOL_SIZE = 512              // Maximum concurrent tickets\r\nMAX_COINS_PER_TICKET = 4096         // Maximum coins per ticket\r\nTICKET_RELEASE_SECONDS = 300        // Ticket expiration time (5 minutes)\r\nTOTAL_RAIDA_SERVERS = 25           // Number of RAIDA servers\r\nRAIDA_SERVER_RCV_TIMEOUT = 32      // Network timeout in seconds\r\n```\r\n\r\n### 3.2 Enhanced Ticket Entry Structure\r\n```\r\nticket_entry_structure:\r\n    created_at: timestamp_type              // Creation timestamp\r\n    ticket: unsigned_32bit_integer          // Unique ticket identifier\r\n    coins: array[MAX_COINS_PER_TICKET] of coin_structure\r\n    claims: array[TOTAL_RAIDA_SERVERS] of character    // Claim tracking by RAIDA\r\n    num_coins: unsigned_32bit_integer       // Number of coins in ticket\r\n    mtx: mutex_type                         // Per-ticket fine-grained mutex\r\n```\r\n\r\n### 3.3 Validation Thread Arguments\r\n```\r\nvalidate_ticket_arg_structure:\r\n    raida_idx: integer                      // Target RAIDA server index\r\n    ticket: unsigned_32bit_integer          // Ticket to validate\r\n    ci: pointer_to_connection_info          // Original connection context\r\n    rv_coins: pointer_to_coin_array         // Returned coin data\r\n    rv_num_coins: integer                   // Number of returned coins\r\n```\r\n\r\n### 3.4 Coin Counter Structure\r\n```\r\ncoin_counter_structure:\r\n    coin: coin_structure                    // Coin identification\r\n    cnt: integer                           // Vote count from RAIDA servers\r\n```\r\n\r\n## 4. Core Command Implementations\r\n\r\n### 4.1. cmd_get_ticket\r\n**Purpose**: Creates healing ticket by validating coins and allocating ticket entry.\r\n\r\n**Request Format**:\r\n```\r\n[16 bytes Challenge Header]\r\n[21 bytes per coin: DN + 4-byte SN + 16-byte AN]\r\n[2 bytes EOF trailer]\r\nMinimum size: 39 bytes (16 + 21 + 2)\r\n```\r\n\r\n**Validation Steps**:\r\n- Verify request size >= 39 bytes\r\n- Calculate coin count: (body_size - 18) / 21\r\n- Verify coin data length is divisible by 21\r\n\r\n**Processing Logic**:\r\n1. **Memory Allocation**:\r\n   - Allocate response bitmap: (total_coins / 8) + 1 + 4 bytes\r\n   - Additional 4 bytes for ticket number storage\r\n\r\n2. **Coin Authentication**:\r\n   - For each coin:\r\n     - Extract denomination and serial number\r\n     - Lock database page containing coin\r\n     - Compare stored AN with provided AN\r\n     - If authentic and no ticket allocated yet:\r\n       - Call get_free_ticket_slot() (returns locked ticket)\r\n       - Add coin to ticket entry\r\n       - Set success bit in bitmap\r\n     - Unlock page\r\n\r\n3. **Response Generation**:\r\n   - All authentic: STATUS_ALL_PASS, return ticket number (4 bytes)\r\n   - All failed: STATUS_ALL_FAIL, no ticket created\r\n   - Mixed results: STATUS_MIXED, return bitmap + ticket number\r\n\r\n4. **Resource Management**:\r\n   - Unlock ticket entry after all operations\r\n   - Track pass/fail counts for status determination\r\n\r\n### 4.2. cmd_validate_ticket\r\n**Purpose**: Validates ticket authenticity and marks claims by RAIDA servers.\r\n\r\n**Request Format**:\r\n```\r\n[16 bytes Challenge Header]\r\n[1 byte RAIDA Index]\r\n[4 bytes Ticket Number]\r\n[2 bytes EOF trailer]\r\nTotal size: exactly 23 bytes\r\n```\r\n\r\n**Validation Steps**:\r\n- Verify request size == 23 bytes\r\n- Validate RAIDA index < TOTAL_RAIDA_SERVERS\r\n- Extract ticket number from request\r\n\r\n**Processing Logic**:\r\n1. **Ticket Retrieval**:\r\n   - Call get_ticket_entry(ticket_number) (returns locked ticket)\r\n   - If not found: return ERROR_NO_TICKET_FOUND\r\n\r\n2. **Claim Validation**:\r\n   - Check if RAIDA has already claimed ticket\r\n   - If already claimed: return ERROR_TICKET_CLAIMED_ALREADY\r\n\r\n3. **Response Generation**:\r\n   - Allocate response buffer: num_coins * 5 bytes\r\n   - For each coin in ticket:\r\n     - Write denomination (1 byte)\r\n     - Write serial number (4 bytes, big-endian format)\r\n\r\n4. **Claim Recording**:\r\n   - Set claims[raida_index] = 1\r\n   - Return STATUS_SUCCESS\r\n\r\n5. **Resource Management**:\r\n   - Unlock ticket entry after all operations (including error paths)\r\n\r\n### 4.3. cmd_find\r\n**Purpose**: Determines coin authentication state by comparing current and proposed ANs.\r\n\r\n**Request Format**:\r\n```\r\n[16 bytes Challenge Header]\r\n[37 bytes per coin: DN + 4-byte SN + 16-byte AN + 16-byte PN]\r\n[2 bytes EOF trailer]\r\nMinimum size: 55 bytes (16 + 37 + 2)\r\n```\r\n\r\n**Validation Steps**:\r\n- Verify request size >= 55 bytes\r\n- Calculate coin count: (body_size - 18) / 37\r\n- Verify coin data length is divisible by 37\r\n\r\n**Processing Logic**:\r\n1. **Memory Allocation**:\r\n   - Allocate response buffer: total_coins bytes (1 byte per coin result)\r\n\r\n2. **Coin State Analysis**:\r\n   - For each coin:\r\n     - Extract denomination, serial number, current AN, proposed AN\r\n     - Lock database page containing coin\r\n     - Compare stored AN with current AN:\r\n       - If match: Set response[i] = 0x1 (AN matches)\r\n     - Compare stored AN with proposed AN:\r\n       - If match: Set response[i] = 0x2 (PAN matches)\r\n     - If neither: Set response[i] = 0x0 (neither matches)\r\n     - Unlock page\r\n\r\n3. **Status Determination**:\r\n   - All AN matches: STATUS_FIND_ALL_AN\r\n   - All PAN matches: STATUS_FIND_ALL_PAN  \r\n   - All neither: STATUS_FIND_NEITHER\r\n   - Mixed results: STATUS_FIND_MIXED (include response array)\r\n\r\n### 4.4. cmd_fix\r\n**Purpose**: Performs distributed coin recovery using cross-RAIDA consensus.\r\n\r\n**Request Format**:\r\n```\r\n[16 bytes Challenge Header]\r\n[5 bytes per coin: DN + 4-byte SN]\r\n[16 bytes PG (Proposed Group identifier)]\r\n[25 * 4 bytes: Ticket numbers from each RAIDA]\r\n[2 bytes EOF trailer]\r\nMinimum size: 139 bytes (16 + 5 + 16 + 100 + 2)\r\n```\r\n\r\n**Validation Steps**:\r\n- Verify request size >= 139 bytes\r\n- Calculate coin count: (body_size - 134) / 5\r\n- Verify coin data length is divisible by 5\r\n\r\n**Complex Processing Logic**:\r\n\r\n1. **Initialization Phase**:\r\n   - Allocate response bitmap: (total_coins / 8) + 1 bytes\r\n   - Allocate coin counters array for vote tracking\r\n   - Initialize coin counter structures with coin data\r\n\r\n2. **Distributed Validation Phase**:\r\n   - For each RAIDA server (0 to TOTAL_RAIDA_SERVERS-1):\r\n     - Extract ticket number for this RAIDA\r\n     - Create thread argument structure\r\n     - Launch thread: send_validate_ticket_job()\r\n\r\n3. **Thread Coordination**:\r\n   - Wait for all threads to complete using pthread_join\r\n   - Process results from each RAIDA server\r\n   - Match returned coins with requested coins\r\n   - Increment vote counters for validated coins\r\n\r\n4. **Consensus Processing**:\r\n   - For each coin:\r\n     - Check if votes > (TOTAL_RAIDA_SERVERS / 2) + 1 (majority)\r\n     - If majority reached:\r\n       - Calculate new AN using MD5 hash\r\n       - Input: RAIDA_number + denomination + SN + PG (22 bytes total)\r\n       - Lock database page\r\n       - Update stored AN with calculated value\r\n       - Set MFS byte\r\n       - Add page to dirty queue\r\n       - Set success bit in response bitmap\r\n       - Unlock page\r\n\r\n5. **Response Generation**:\r\n   - All successful: STATUS_ALL_PASS\r\n   - All failed: STATUS_ALL_FAIL\r\n   - Mixed: STATUS_MIXED (include bitmap)\r\n\r\n## 5. Network Communication Functions\r\n\r\n### 5.1. send_validate_ticket_job(thread_argument)\r\n**Purpose**: Thread function for cross-RAIDA ticket validation.\r\n\r\n**Thread Execution Flow**:\r\n\r\n1. **Connection Setup**:\r\n   - Extract target RAIDA host and port from configuration\r\n   - Create TCP socket with non-blocking mode\r\n   - Set receive timeout to RAIDA_SERVER_RCV_TIMEOUT\r\n   - Establish connection using select() for timeout handling\r\n\r\n2. **Request Construction**:\r\n   - Build 32-byte request header:\r\n     - Router version, split ID, target RAIDA ID\r\n     - Command group 2, command 50 (validate_ticket)\r\n     - Coin ID from original connection\r\n     - Body length: 16 + 1 + 4 + 2 = 23 bytes\r\n   - Build request body:\r\n     - 16-byte challenge (sequential bytes 0-11 + CRC32)\r\n     - 1-byte source RAIDA number\r\n     - 4-byte ticket number\r\n     - 2-byte trailer (0x3e, 0x3e)\r\n\r\n3. **Response Processing**:\r\n   - Read 32-byte response header\r\n   - Validate RAIDA ID and status code\r\n   - Extract body size from header\r\n   - Read response body containing coin data\r\n   - Validate trailer bytes\r\n   - Parse coin data: denomination + serial number per 5-byte record\r\n\r\n4. **Result Storage**:\r\n   - Allocate array for returned coins\r\n   - Store coin data in thread argument structure\r\n   - Validate each coin against database for existence\r\n\r\n5. **Error Handling**:\r\n   - Network timeouts and connection failures\r\n   - Invalid response format handling\r\n   - Resource cleanup on all error paths\r\n\r\n## 6. Enhanced Ticket Management\r\n\r\n### 6.1 Fine-Grained Locking System\r\n- **Per-Ticket Mutexes**: Each ticket entry has individual mutex\r\n- **Lock Acquisition**: get_free_ticket_slot() returns locked ticket\r\n- **Lock Management**: Caller responsible for unlocking via unlock_ticket_entry()\r\n- **Non-Blocking Access**: get_free_ticket_slot() uses trylock for efficiency\r\n\r\n### 6.2 Ticket Lifecycle Management\r\n\r\n#### 6.2.1 init_ticket_storage()\r\n- Initialize each ticket entry with creation timestamp 0\r\n- Initialize per-ticket mutex for each entry\r\n- Return error if any mutex initialization fails\r\n\r\n#### 6.2.2 check_tickets()\r\n- Iterate through all ticket entries with individual locking\r\n- Lock each ticket, check expiration, unlock immediately\r\n- Free expired tickets by resetting creation timestamp\r\n\r\n#### 6.2.3 get_free_ticket_slot()\r\n- Use pthread_mutex_trylock() to avoid blocking\r\n- Find first available slot (creation timestamp 0)\r\n- Initialize ticket with random number and current timestamp\r\n- Return locked ticket entry to caller\r\n\r\n#### 6.2.4 get_ticket_entry(ticket_number)\r\n- Search all tickets for matching ticket number\r\n- Lock and return matching ticket entry\r\n- Caller must unlock after use\r\n\r\n## 7. Database Integration Requirements\r\n\r\n### 7.1 Page Management Protocol\r\nFor each database access:\r\n1. **Page Retrieval**: get_page_by_sn_lock(denomination, serial_number)\r\n2. **Data Access**: Calculate record offset: (sn % RECORDS_PER_PAGE) * 17\r\n3. **AN Comparison**: Compare bytes 0-15 of record with provided AN\r\n4. **Modification**: Update AN and MFS byte for successful fixes\r\n5. **Persistence**: add_page_to_dirty_queue(page) for modified pages\r\n6. **Release**: unlock_page(page)\r\n\r\n### 7.2 MD5 Hash Calculation for Fix Command\r\n- Input data: RAIDA_number (1) + denomination (1) + SN (4) + PG (16) = 22 bytes\r\n- Use md5ilen() function for hash calculation\r\n- Replace stored AN with calculated MD5 hash\r\n- Set MFS byte to current modification sequence\r\n\r\n## 8. Error Handling and Recovery\r\n\r\n### 8.1 Network Error Management\r\n- Connection timeouts handled with select() and timeout values\r\n- Socket errors logged with specific RAIDA server context\r\n- Failed RAIDA connections continue processing with remaining servers\r\n- Thread synchronization ensures all threads complete before processing\r\n\r\n### 8.2 Resource Management\r\n- All allocated memory freed on error paths\r\n- Ticket entries unlocked on all exit conditions\r\n- Thread cleanup handled by pthread_join operations\r\n- Socket resources properly closed on all error conditions\r\n\r\n### 8.3 Consensus Validation\r\n- Majority vote required for coin recovery (> 50% + 1 RAIDA servers)\r\n- Individual coin failures don't affect other coins in batch\r\n- Partial success tracked with bitmap responses\r\n- Invalid responses from RAIDA servers logged but don't block processing\r\n\r\n## 9. Performance Considerations\r\n\r\n### 9.1 Concurrency Optimizations\r\n- Fine-grained per-ticket locking reduces contention\r\n- Non-blocking ticket allocation with trylock\r\n- Parallel RAIDA server communication reduces latency\r\n- Individual page locking minimizes database contention\r\n\r\n### 9.2 Memory Efficiency\r\n- Response buffers sized based on actual coin counts\r\n- Thread-local storage for network communication\r\n- Temporary arrays freed immediately after use\r\n- Bitmap responses minimize network overhead\r\n\r\n### 9.3 Network Optimization\r\n- Parallel thread execution for RAIDA communication\r\n- Connection timeouts prevent hanging operations\r\n- Non-blocking socket operations during connection phase\r\n- Efficient request/response format minimizes bandwidth\r\n\r\nThis specification provides complete implementation guidance for the CloudCoin healing command system while remaining language-agnostic and accurately reflecting the actual implementation requirements."
        }
    ]
}