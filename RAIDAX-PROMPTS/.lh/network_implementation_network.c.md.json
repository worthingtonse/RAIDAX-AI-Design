{
    "sourceFile": "network_implementation_network.c.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1751889507947,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1751959335346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,5 +60,302 @@\n \r\n 4. Error Handling\r\n All socket operations must handle non-blocking error codes (e.g., EAGAIN, EWOULDBLOCK) by returning control to the event loop.\r\n \r\n-Any other error must result in the connection being closed and its resources being freed.\n\\ No newline at end of file\n+Any other error must result in the connection being closed and its resources being freed.\r\n+\r\n+\r\n+\r\n+///////////////////////////////////////////////\r\n+\r\n+# Language-Agnostic Specification: CloudCoin Network Layer Implementation\r\n+\r\n+## 1. Module Purpose\r\n+This module implements a high-performance, event-driven network layer for handling both TCP and UDP connections in the CloudCoin RAIDA system. It uses an epoll-based event loop with a thread pool for request processing, supporting thousands of concurrent connections while maintaining low latency and high throughput.\r\n+\r\n+## 2. System Architecture Overview\r\n+\r\n+### 2.1 Core Components\r\n+- **Event-Driven I/O**: Single-threaded epoll event loop for maximum efficiency\r\n+- **Dual Protocol Support**: Simultaneous TCP and UDP handling on the same port\r\n+- **Thread Pool Integration**: Worker threads for CPU-intensive request processing\r\n+- **Cross-Thread Communication**: EventFD-based signaling between I/O and worker threads\r\n+- **Connection State Management**: Finite state machine for TCP connection lifecycle\r\n+\r\n+### 2.2 Performance Characteristics\r\n+- **Non-Blocking I/O**: All socket operations are non-blocking for scalability\r\n+- **Edge-Triggered Events**: Epoll configured for edge-triggered mode for efficiency\r\n+- **Connection Tracking**: Global array for managing active connections by file descriptor\r\n+\r\n+## 3. System Constants and Configuration\r\n+\r\n+### 3.1 Network Configuration\r\n+```\r\n+RAIDA_EPOLL_TIMEOUT = 10000 milliseconds\r\n+MAXEPOLLSIZE = 10000 events\r\n+MAX_FDS = 65535 file descriptors\r\n+MAX_BODY_SIZE = 65536 bytes\r\n+SOCKET_TIMEOUT = 2 seconds\r\n+MOD_QUEUE_SIZE = 1024 connections\r\n+```\r\n+\r\n+### 3.2 TCP Keep-Alive Settings\r\n+```\r\n+keepalive = 1 (enabled)\r\n+keep_idle = 60 seconds\r\n+keep_interval = 10 seconds  \r\n+keep_count = 5 probes\r\n+```\r\n+\r\n+## 4. Data Structures\r\n+\r\n+### 4.1 Connection Information Structure\r\n+Each connection must track the following state information:\r\n+- Socket file descriptor\r\n+- Client IP address (15 character string plus null terminator)\r\n+- Connection start timestamp\r\n+- Current connection state (enumerated value)\r\n+- Read buffer for request headers (fixed size: REQUEST_HEADER_SIZE)\r\n+- Bytes read and bytes expected for current read operation\r\n+- Dynamically allocated body buffer and body size\r\n+- Write buffer, output buffer, and write progress tracking\r\n+- Socket address structure (for UDP connections only)\r\n+- Protocol header fields: session_id, command, version, raida_id, reserved\r\n+\r\n+### 4.2 Connection State Machine\r\n+Four distinct states manage the TCP connection lifecycle:\r\n+- STATE_WANT_READ_HEADER: Waiting to read complete request header\r\n+- STATE_WANT_READ_BODY: Waiting to read complete request body  \r\n+- STATE_PROCESSING: Request being processed by worker thread\r\n+- STATE_WANT_WRITE: Ready to write response data\r\n+\r\n+### 4.3 Global Management Structures\r\n+- Connection array indexed by file descriptor (size MAX_FDS)\r\n+- Circular modification queue for cross-thread write signaling\r\n+- Queue head and tail indices with mutex protection\r\n+- Global epoll file descriptor and eventfd for cross-thread signaling\r\n+\r\n+## 5. Core Network Operations\r\n+\r\n+### 5.1 System Initialization\r\n+The main initialization function must:\r\n+- Create epoll instance for event management\r\n+- Create eventfd for cross-thread communication with non-blocking flag\r\n+- Initialize TCP listening socket with stream protocol\r\n+- Initialize UDP socket with datagram protocol\r\n+- Add all file descriptors to epoll with edge-triggered input events\r\n+- Enter main event loop processing until shutdown signal\r\n+\r\n+### 5.2 TCP Socket Configuration\r\n+TCP socket setup requires:\r\n+- Create socket with IPv4 address family and stream type\r\n+- Enable SO_REUSEADDR socket option for address reuse\r\n+- Configure non-blocking mode using file control flags\r\n+- Bind to any address (INADDR_ANY) on configured port\r\n+- Start listening with maximum connection backlog (SOMAXCONN)\r\n+\r\n+### 5.3 UDP Socket Configuration  \r\n+UDP socket setup requires:\r\n+- Create socket with IPv4 address family and datagram type\r\n+- Configure non-blocking mode using file control flags\r\n+- Bind to any address (INADDR_ANY) on configured port\r\n+\r\n+## 6. Event Loop Processing\r\n+\r\n+### 6.1 Main Event Loop\r\n+The central event loop must:\r\n+- Wait for events using epoll with configured timeout\r\n+- Handle interrupted system calls by continuing loop\r\n+- Process each returned event based on file descriptor type\r\n+- Route TCP listening socket events to new connection handler\r\n+- Route UDP socket events to datagram request handler\r\n+- Route eventfd events to write queue processor\r\n+- Route client connection events to connection event handler\r\n+\r\n+### 6.2 TCP Connection Acceptance\r\n+New TCP connection handling requires:\r\n+- Accept all pending connections in loop until EAGAIN/EWOULDBLOCK\r\n+- Configure each accepted socket for non-blocking operation\r\n+- Apply TCP keep-alive settings with specified parameters\r\n+- Extract and store client IP address from connection info\r\n+- Allocate and initialize connection information structure\r\n+- Add client socket to epoll for input events with edge triggering\r\n+\r\n+### 6.3 Connection Event Processing\r\n+Connection event routing must:\r\n+- Check for error events (EPOLLERR, EPOLLHUP) and close connection\r\n+- Process read events when EPOLLIN flag is set\r\n+- Process write events when EPOLLOUT flag is set\r\n+\r\n+## 7. TCP Data Transfer Management\r\n+\r\n+### 7.1 Read Event Handling\r\n+Read processing implements a state machine:\r\n+- For STATE_WANT_READ_HEADER: Read into header buffer until complete\r\n+- For STATE_WANT_READ_BODY: Read into body buffer until complete\r\n+- Handle EAGAIN/EWOULDBLOCK by returning to wait for more data\r\n+- Handle connection close (zero bytes read) by cleaning up connection\r\n+- Validate header when complete and transition to body read if needed\r\n+- Validate and decrypt body when complete\r\n+- Submit complete requests to thread pool for processing\r\n+- Handle oversized body requests by sending error response\r\n+\r\n+### 7.2 Write Event Handling\r\n+Write processing must:\r\n+- Only process connections in STATE_WANT_WRITE\r\n+- Send data from write buffer starting at current write position\r\n+- Handle EAGAIN/EWOULDBLOCK by waiting for next write event\r\n+- Update bytes written counter after each successful send\r\n+- Close connection when all response data has been sent\r\n+\r\n+## 8. UDP Request Processing\r\n+\r\n+### 8.1 Datagram Handling\r\n+UDP request processing requires:\r\n+- Read all pending datagrams in loop until EAGAIN/EWOULDBLOCK\r\n+- Allocate temporary buffer using configured UDP payload threshold\r\n+- Extract client address information from recvfrom operation\r\n+- Validate minimum packet size against REQUEST_HEADER_SIZE\r\n+- Create temporary connection information for request processing\r\n+- Validate header and extract body if present\r\n+- Process request immediately without state machine (synchronous)\r\n+- Send error responses for malformed or oversized requests\r\n+\r\n+## 9. Cross-Thread Communication\r\n+\r\n+### 9.1 Write Queue Management\r\n+Thread-safe queue operations:\r\n+- Push operation adds connection to tail of circular queue\r\n+- Pop operation removes connection from head of circular queue\r\n+- Mutex protection around all queue modifications\r\n+- Queue overflow detection when tail catches up to head\r\n+\r\n+### 9.2 Write Signaling Mechanism\r\n+Worker threads signal main I/O thread by:\r\n+- Adding connection to modification queue\r\n+- Writing 64-bit value to eventfd to wake epoll loop\r\n+- Main thread processes eventfd events by clearing value and processing queue\r\n+\r\n+### 9.3 Write Event Arming\r\n+Queue processing updates epoll registration:\r\n+- Extract all queued connections requiring write events\r\n+- Modify epoll registration to listen for EPOLLOUT events\r\n+- Use edge-triggered mode for write event notification\r\n+\r\n+## 10. Socket Configuration Utilities\r\n+\r\n+### 10.1 Blocking Mode Control\r\n+Non-blocking configuration:\r\n+- Get current file descriptor flags\r\n+- Set O_NONBLOCK flag while preserving other flags\r\n+\r\n+Blocking configuration:\r\n+- Get current file descriptor flags  \r\n+- Clear O_NONBLOCK flag while preserving other flags\r\n+\r\n+## 11. Connection Lifecycle Management\r\n+\r\n+### 11.1 Connection Allocation\r\n+Connection structure initialization:\r\n+- Allocate memory for connection information structure\r\n+- Initialize all fields to zero\r\n+- Set socket file descriptor\r\n+- Set initial state to STATE_WANT_READ_HEADER\r\n+- Set bytes to read to REQUEST_HEADER_SIZE\r\n+- Record current timestamp as start time\r\n+\r\n+### 11.2 Connection Cleanup\r\n+Resource deallocation sequence:\r\n+- Free socket address structure if allocated (UDP connections)\r\n+- Free body buffer if allocated\r\n+- Free output buffer if allocated  \r\n+- Free write buffer if allocated\r\n+- Free main connection structure\r\n+\r\n+### 11.3 Connection Termination\r\n+Connection closure process:\r\n+- Remove socket from epoll monitoring\r\n+- Close socket file descriptor\r\n+- Clear connection array entry\r\n+- Free all associated resources\r\n+\r\n+## 12. Error Handling and Recovery\r\n+\r\n+### 12.1 Network Error Management\r\n+- Socket creation failures: Log error and return failure code\r\n+- Binding failures: Log error with system error details\r\n+- Accept failures: Distinguish between EAGAIN and actual errors\r\n+- Read/write failures: Handle EAGAIN separately from connection errors\r\n+- Connection drops: Clean up resources and continue serving others\r\n+\r\n+### 12.2 Resource Error Management\r\n+- Memory allocation failures: Send error response and clean up\r\n+- File descriptor exhaustion: Log error and reject new connections\r\n+- Queue overflow: Log error and continue processing\r\n+- Protocol validation failures: Send appropriate error codes\r\n+\r\n+### 12.3 Security Error Handling\r\n+- Oversized body requests: Reject with error response\r\n+- Invalid header validation: Send error and close connection\r\n+- Buffer overflow attempts: Enforce strict bounds checking\r\n+- Malformed packets: Reject with minimal processing\r\n+\r\n+## 13. Performance Optimization Strategies\r\n+\r\n+### 13.1 I/O Efficiency\r\n+- Edge-triggered epoll events minimize system calls\r\n+- Non-blocking operations prevent thread blocking\r\n+- Batch event processing reduces context switching overhead\r\n+- Direct buffer operations minimize memory copying\r\n+\r\n+### 13.2 Memory Management\r\n+- Fixed-size header buffers avoid repeated allocation\r\n+- Dynamic body buffers allocated only when needed\r\n+- Connection structures reused through allocation pool\r\n+- Resource cleanup on all exit paths prevents leaks\r\n+\r\n+### 13.3 Thread Coordination\r\n+- Single I/O thread eliminates lock contention in event loop\r\n+- Worker threads operate on isolated connection structures\r\n+- EventFD provides efficient cross-thread signaling\r\n+- Modification queue batches write event updates\r\n+\r\n+## 14. Integration Requirements\r\n+\r\n+### 14.1 External Function Dependencies\r\n+- validate_header: Validates request header and extracts fields\r\n+- validate_decrypt_body: Validates and decrypts request body\r\n+- run_command: Processes complete request in worker thread\r\n+- send_command_error: Sends error response to client\r\n+- thpool_add_work: Submits work to thread pool\r\n+- thpool_num_threads_working: Returns active worker thread count\r\n+\r\n+### 14.2 Configuration Dependencies\r\n+- config.port: Network port for listening sockets\r\n+- config.udp_payload_threshold: Maximum UDP packet size\r\n+- is_finished: Global shutdown signal flag\r\n+\r\n+### 14.3 Protocol Constants\r\n+- REQUEST_HEADER_SIZE: Size of protocol request header\r\n+- Error codes: NO_ERROR, ERROR_INVALID_PACKET_LENGTH, ERROR_MEMORY_ALLOC\r\n+\r\n+## 15. Security and Resource Protection\r\n+\r\n+### 15.1 Input Validation\r\n+- Request header validation before processing\r\n+- Body size limits enforced against MAX_BODY_SIZE\r\n+- Packet size validation for UDP requests\r\n+- Buffer bounds checking on all operations\r\n+\r\n+### 15.2 Resource Limits\r\n+- Maximum concurrent connections limited by MAX_FDS\r\n+- Memory usage limited by body size restrictions\r\n+- Connection timeouts prevent resource exhaustion\r\n+- Queue sizes prevent unbounded memory growth\r\n+\r\n+### 15.3 Attack Mitigation\r\n+- Malformed request rejection with minimal processing\r\n+- Buffer overflow prevention through size validation\r\n+- Connection flooding protection through limits\r\n+- Memory exhaustion protection through size limits\r\n+\r\n+This specification provides complete implementation guidance for a high-performance, event-driven network layer while remaining language-agnostic and focusing only on the actual functionality present in the source code.\n\\ No newline at end of file\n"
                },
                {
                    "date": 1751960038193,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,9 +66,9 @@\n \r\n \r\n ///////////////////////////////////////////////\r\n \r\n-# Language-Agnostic Specification: CloudCoin Network Layer Implementation\r\n+#  Specification: CloudCoin Network Layer Implementation\r\n \r\n ## 1. Module Purpose\r\n This module implements a high-performance, event-driven network layer for handling both TCP and UDP connections in the CloudCoin RAIDA system. It uses an epoll-based event loop with a thread pool for request processing, supporting thousands of concurrent connections while maintaining low latency and high throughput.\r\n \r\n"
                }
            ],
            "date": 1751889507947,
            "name": "Commit-0",
            "content": "Language-Agnostic Specification: Network Implementation\r\n1. Module Purpose\r\nThis module provides the concrete implementation for a high-performance, non-blocking network server core. It must use an OS-level asynchronous I/O event notification system (e.g., epoll, kqueue, IOCP) and be designed around an event loop architecture.\r\n\r\n2. Architectural Requirements\r\nAsynchronous, Edge-Triggered I/O: The event notification system must be configured for \"edge-triggered\" behavior. In response to a single notification, the application must perform I/O in a loop until the operation would block.\r\n\r\nState Management: A concurrent-safe mapping (e.g., a hash map) must be used to associate a connection's unique identifier with its state object.\r\n\r\nWorker Thread Pool Integration: The network layer must dispatch completed requests to a separate worker thread pool for processing.\r\n\r\nCross-Thread Signaling: A thread-safe signaling mechanism (e.g., an eventfd) must be used to allow worker threads to safely notify the main I/O thread when a connection is ready to be written to.\r\n\r\n3. Core Logic and Event Handling\r\n3.1. Main Event Loop\r\nRole: To initialize sockets and the signaling mechanism, register them with the event multiplexer, and loop indefinitely to dispatch events.\r\n\r\nLogic:\r\n\r\nInitialize a TCP listener, a UDP socket, and the signaling mechanism.\r\n\r\nRegister all three with the event multiplexer.\r\n\r\nLoop, calling the event multiplexer's wait function.\r\n\r\nIf an event is from the signaling mechanism, process the queue of connections now ready for writing, modifying their registration to listen for \"write-ready\" events.\r\n\r\nDispatch all other I/O events to their respective handlers.\r\n\r\n3.2. Handling New Connections\r\nRole: To accept all pending incoming TCP connections.\r\n\r\nLogic:\r\n\r\nMust be implemented in a loop that calls the system's accept function until all pending connections are accepted.\r\n\r\nTCP Keep-Alive: For each newly accepted TCP connection, the implementation must enable the TCP keep-alive socket option to detect and clean up dead connections.\r\n\r\nFor each new connection, create a connection state object and register it with the event multiplexer for read events.\r\n\r\n3.3. Handling Readable Sockets\r\nRole: To read all available data from a socket without blocking.\r\n\r\nLogic:\r\n\r\nMust be implemented in a loop to completely drain the socket's read buffer.\r\n\r\nSecurity Check: After parsing the header, must validate that the client-specified body_size does not exceed MAX_BODY_SIZE.\r\n\r\nOnce a full request is read, dispatch it to the worker thread pool.\r\n\r\n3.4. Handling Writable Sockets\r\nRole: To write all pending data to a socket without blocking.\r\n\r\nLogic:\r\n\r\nMust be implemented in a loop that continues as long as there is data in the connection's write_buffer.\r\n\r\nOnce all data has been written, the connection must be closed.\r\n\r\n4. Error Handling\r\nAll socket operations must handle non-blocking error codes (e.g., EAGAIN, EWOULDBLOCK) by returning control to the event loop.\r\n\r\nAny other error must result in the connection being closed and its resources being freed."
        }
    ]
}