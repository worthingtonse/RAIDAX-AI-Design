#  Specification:  Protocol Implementation

## 1. Module Purpose
This module implements the enhanced core protocol handling for the CloudCoin RAIDA system with advanced cryptographic security. It features secure per-message nonce generation, improved encryption handling, streamlined ticket management, and enhanced response header protocol for better security and performance.

## 2. System Architecture Overview

### 2.1 Core Components
- **Enhanced Cryptographic Security**: Secure per-message nonce generation and management
- **Request Validation**: Header and body validation with protocol compliance checking
- **Command Dispatch**: Multi-dimensional command routing by group and command index
- **Advanced Encryption Management**: Separate nonces for request and response encryption
- **Response Generation**: Enhanced header construction with cryptographic nonce transmission
- **Optimized Ticket System**: Streamlined memory-based ticket pool with fine-grained locking
- **Statistical Logging**: Performance and operation tracking

### 2.2 Security Enhancements
- **Cryptographically Secure Nonces**: Per-message nonce generation for CTR mode encryption
- **Separate Request/Response Nonces**: Independent nonces for bidirectional security
- **Enhanced Header Protocol**: Response nonce transmission for client decryption
- **Improved Key Management**: Secure nonce handling throughout encryption lifecycle

## 3. System Constants and Configuration

### 3.1 Enhanced Security Constants
```
REQUEST_HEADER_SIZE = 32 bytes
RESPONSE_HEADER_SIZE = 32 bytes
NONCE_SIZE = 12 bytes                 // Standard secure nonce size for CTR mode (96 bits)
TOTAL_RAIDA_SERVERS = 25
TICKET_POOL_SIZE = 512
MAX_COINS_PER_TICKET = 4096
TICKET_RELEASE_SECONDS = 300
RAIDA_SERVER_RCV_TIMEOUT = 32 seconds
MAX_COMMAND_GROUP = 13 (FILESYSTEM)
MAX_COMMAND = 255
MAX_SHARD = 3 (SHARD_NEW)
```

### 3.2 Encryption Types
```
ENCRYPTION_TYPE_NONE = 0     // No encryption
ENCRYPTION_TYPE_AES = 1      // AES encryption using coin AN
ENCRYPTION_TYPE_LOCKER = 2   // Locker-based encryption
```

### 3.3 Protocol Trailer
All request and response bodies must end with a 2-byte trailer: 0x3e, 0x3e

## 4. Enhanced Data Structures

### 4.1 Enhanced Connection Information Structure
The protocol layer connection information structure includes:
- Echo bytes (2 bytes for client identification)
- Body size and body buffer pointer
- Encryption denomination, serial number, type, and AN (16 bytes)
- **Enhanced nonce management**: Separate request and response nonces
- **request_nonce**: NONCE_SIZE bytes from client request
- **response_nonce**: NONCE_SIZE bytes generated by server
- Output buffer and size for response data
- Command status code
- Challenge hash (16 bytes)
- Command group and command index
- Shard identifier
- Coin identifier
- Execution time tracking

### 4.2 Basic Coin Structure
Each coin reference must contain:
- Denomination (signed 8-bit value)
- Serial number (32-bit unsigned integer)

### 4.3 Enhanced Ticket Entry Structure
Each ticket entry must contain:
- Creation timestamp
- Ticket number (32-bit unsigned integer)
- Array of coins (up to MAX_COINS_PER_TICKET)
- Claims array (TOTAL_RAIDA_SERVERS elements)
- Number of coins (32-bit unsigned integer)
- **Per-slot mutex for fine-grained locking**

## 5. Core Protocol Functions

### 5.1 Enhanced Request Validation

#### 5.1.1 validate_header(buffer, connection_info)
Enhanced header validation must verify:
- Router version (must be 1)
- Split ID (must be 0)
- RAIDA ID (must match configured RAIDA number)
- Shard ID (range 0 to MAX_SHARD)
- Command group (range 0 to MAX_COMMAND_GROUP)
- Command index (range 0 to MAX_COMMAND, must exist in command table)
- Coin ID (must match configured coin ID)
- Encryption type (must be valid type)
- Body size extraction from bytes 22-23
- **Enhanced nonce extraction**: Read full NONCE_SIZE bytes from header bytes 20-31

For AES encryption, extract and validate:
- Encryption denomination from byte 17
- Encryption serial number from bytes 18-21
- Retrieve coin AN from database page
- **Store extracted nonce in request_nonce field**

For Locker encryption, extract:
- Encryption denomination from byte 17
- Retrieve coin AN from index using get_coins_from_index_by_prefix
- **Store extracted nonce in request_nonce field**

#### 5.1.2 validate_decrypt_body(connection_info)
Enhanced body validation must:
- Verify minimum length (18 bytes: 16-byte challenge + 2-byte trailer)
- Validate trailer bytes (0x3e, 0x3e)
- **Use request_nonce for body decryption** if encryption is enabled
- Extract challenge hash (first 16 bytes after decryption)
- Calculate CRC32 of first 12 challenge bytes
- Verify CRC32 matches bytes 12-15 of challenge

### 5.2 Command Processing

#### 5.2.1 run_command(connection_info)
Streamlined command execution process:
- Look up command handler in two-dimensional command table
- Validate command handler exists
- Execute command handler function
- Call prepare_response after command completion

#### 5.2.2 Command Dispatch Table
The system maintains a two-dimensional array of command handlers:
- First dimension: Command group (0-13)
- Second dimension: Command index (0-255)
- Populated entries point to specific command handler functions
- NULL entries indicate invalid commands

### 5.3 Enhanced Response Management

#### 5.3.1 prepare_response(connection_info)
Enhanced response preparation with cryptographic security:

**UDP Response (immediate)**:
- Add 2-byte trailer to output size
- Allocate write buffer for header + body + trailer
- Generate response header
- Copy body content (if present)
- Add trailer bytes
- Send response immediately using sendto
- Clean up resources

**TCP Response (deferred with enhanced security)**:
- **Generate cryptographically secure response nonce** using generate_random_bytes()
- Add 2-byte trailer to output size
- Allocate write buffer for header + body + trailer
- Generate response header with embedded response nonce
- **Encrypt body using unique response_nonce** if encryption is enabled
- Copy encrypted body content
- Add trailer bytes
- Set connection state to STATE_WANT_WRITE
- Signal I/O thread for write processing

#### 5.3.2 get_response_header(buffer, status, command_group, connection_info)
Enhanced response header construction:
- Byte 0: RAIDA number
- Byte 1: Shard ID (always 0)
- Byte 2: Response status code
- Byte 3: Command group
- Bytes 4-5: UDP count (always 0, 1)
- Bytes 6-7: Echo bytes from request
- Byte 8: Reserved (0)
- Bytes 9-11: Output size (24-bit big-endian)
- Bytes 12-15: Execution time (32-bit big-endian microseconds)
- **Bytes 16-27: Response nonce for client decryption (NONCE_SIZE bytes)**
- **Bytes 28-31: Reserved/padding**

### 5.4 Error Handling

#### 5.4.1 send_command_error(error_code, connection_info)
Error response processing:
- Set command status to error code
- Set output size to 0 (no body)
- Free existing output buffer
- Call prepare_response for error transmission

## 6. Enhanced Cryptographic Security

### 6.1 Secure Nonce Management
- **Request Nonce**: Extracted from client request header (bytes 20-31)
- **Response Nonce**: Generated using cryptographically secure random bytes
- **Nonce Size**: NONCE_SIZE (12 bytes) for optimal CTR mode security
- **Nonce Uniqueness**: Each response uses a unique, randomly generated nonce

### 6.2 Enhanced Encryption Protocol
- **Request Decryption**: Uses client-provided request_nonce from header
- **Response Encryption**: Uses server-generated response_nonce
- **Key Management**: AES uses 16-byte AN from coin database or locker index
- **Security Improvement**: Separate nonces prevent nonce reuse vulnerabilities

### 6.3 Cryptographic Operations
- **CTR Mode**: Enhanced CTR mode encryption/decryption with secure nonces
- **Random Generation**: generate_random_bytes() for cryptographically secure nonces
- **CRC32**: Challenge integrity verification
- **MD5**: Various protocol hash operations

## 7. Streamlined Ticket Management System

### 7.1 Optimized Ticket Pool Operations

#### 7.1.1 init_ticket_storage()
Streamlined ticket system initialization:
- Clear all ticket entries in global pool
- **Initialize per-slot mutex for each ticket entry**
- Remove global mutex dependency for operations
- Return error if any mutex initialization fails

#### 7.1.2 get_free_ticket_slot()
Optimized ticket allocation:
- **Use pthread_mutex_trylock() for non-blocking access**
- Search for ticket entry with creation timestamp 0
- Initialize ticket with random number and current timestamp
- Clear coin count and claims array
- **Return locked ticket entry to caller**

#### 7.1.3 get_ticket_entry(ticket_number)
Enhanced ticket retrieval:
- Search pool for ticket with matching ticket number
- **Lock individual ticket entry when found**
- Skip entries with creation timestamp 0
- **Return locked ticket entry if found, NULL otherwise**

#### 7.1.4 unlock_ticket_entry(ticket_entry)
Explicit ticket unlock management:
- **Unlock the specific ticket entry mutex**
- Essential for proper resource management

#### 7.1.5 check_tickets()
Streamlined ticket cleanup:
- Iterate through all ticket entries
- **Lock each ticket individually for expiry check**
- Calculate time difference from creation timestamp
- Free tickets older than TICKET_RELEASE_SECONDS
- **Unlock each ticket immediately after processing**

### 7.2 Performance Optimizations
- **Eliminated Global Mutex**: Per-ticket locking removes bottlenecks
- **Non-Blocking Allocation**: trylock prevents thread starvation
- **Reduced Lock Contention**: Individual ticket operations don't block others
- **Simplified Logic**: Streamlined ticket management code

## 8. Utility Functions

### 8.1 get_body_payload(connection_info)
Returns pointer to request body content after the 16-byte challenge header.

### 8.2 write_stat(connection_info)
Logs statistical information including:
- Timestamp in microseconds
- Client IP address
- Encryption denomination and serial number
- Command group and command index
- Execution time
- Command status

### 8.3 finish_command(connection_info)
Resource cleanup:
- For TCP connections: Log completion status
- For UDP connections: Free connection info structure

## 9. Integration Dependencies

### 9.1 Enhanced Cryptographic Integration
- **generate_random_bytes**: Cryptographically secure random number generation
- **crypt_ctr**: Enhanced CTR mode encryption/decryption with nonce support
- **crc32b**: CRC32 calculation for challenge verification
- **md5**: MD5 hash calculation for various operations

### 9.2 Database Layer Integration
- get_page_by_sn_lock: Retrieve coin data page
- unlock_page: Release page lock
- get_coins_from_index_by_prefix: Retrieve coin from index by partial AN

### 9.3 Network Layer Integration
- arm_socket_for_write: Signal I/O thread for TCP write
- free_ci: Clean up connection information

### 9.4 Utility Integration
- get_sn: Extract serial number from byte array
- Various time and random number functions

## 10. Performance Optimizations

### 10.1 Enhanced Security Performance
- **Secure Random Generation**: Efficient cryptographically secure nonce generation
- **Optimized Encryption**: Separate nonces eliminate nonce management overhead
- **Reduced Complexity**: Streamlined encryption handling

### 10.2 Streamlined Ticket Operations
- **Per-ticket locking eliminates global bottlenecks**
- **Non-blocking ticket allocation improves responsiveness**
- **Individual ticket expiry checking reduces lock contention**
- **Simplified ticket management reduces CPU overhead**

### 10.3 Protocol Efficiency
- **Command Dispatch**: Two-dimensional array provides O(1) command lookup
- **Header Processing**: Streamlined validation with enhanced security
- **Memory Management**: Optimized buffer allocation and cleanup

## 11. Security Enhancements

### 11.1 Cryptographic Improvements
- **Nonce Uniqueness**: Each response uses a unique, secure nonce
- **CTR Mode Security**: Proper nonce handling prevents security vulnerabilities
- **Random Quality**: Cryptographically secure random number generation
- **Key Isolation**: Separate nonces for request and response encryption

### 11.2 Protocol Security
- **Header Authentication**: Enhanced header validation with nonce verification
- **Challenge Verification**: Robust challenge-response authentication
- **Error Handling**: Secure error responses that don't leak information
- **Resource Protection**: Secure memory and resource management


This specification provides complete implementation guidance for the enhanced CloudCoin protocol layer with advanced cryptographic security and streamlined ticket management while remaining language-agnostic and accurately reflecting the security-focused implementation improvements.