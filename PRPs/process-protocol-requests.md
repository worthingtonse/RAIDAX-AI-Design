<!-- #  Specification:  Protocol Implementation

## 1. Module Purpose
This module implements the enhanced core protocol handling for the CloudCoin RAIDA system with advanced cryptographic security. It features secure per-message nonce generation, improved encryption handling, streamlined ticket management, and enhanced response header protocol for better security and performance.

## 2. System Architecture Overview

### 2.1 Core Components
- **Enhanced Cryptographic Security**: Secure per-message nonce generation and management
- **Request Validation**: Header and body validation with protocol compliance checking
- **Command Dispatch**: Multi-dimensional command routing by group and command index
- **Advanced Encryption Management**: Separate nonces for request and response encryption
- **Response Generation**: Enhanced header construction with cryptographic nonce transmission
- **Optimized Ticket System**: Streamlined memory-based ticket pool with fine-grained locking
- **Statistical Logging**: Performance and operation tracking

### 2.2 Security Enhancements
- **Cryptographically Secure Nonces**: Per-message nonce generation for CTR mode encryption
- **Separate Request/Response Nonces**: Independent nonces for bidirectional security
- **Enhanced Header Protocol**: Response nonce transmission for client decryption
- **Improved Key Management**: Secure nonce handling throughout encryption lifecycle

## 3. System Constants and Configuration

### 3.1 Enhanced Security Constants
```
REQUEST_HEADER_SIZE = 32 bytes
RESPONSE_HEADER_SIZE = 32 bytes
NONCE_SIZE = 12 bytes                 // Standard secure nonce size for CTR mode (96 bits)
TOTAL_RAIDA_SERVERS = 25
TICKET_POOL_SIZE = 512
MAX_COINS_PER_TICKET = 4096
TICKET_RELEASE_SECONDS = 300
RAIDA_SERVER_RCV_TIMEOUT = 32 seconds
MAX_COMMAND_GROUP = 13 (FILESYSTEM)
MAX_COMMAND = 255
MAX_SHARD = 3 (SHARD_NEW)
```

### 3.2 Encryption Types
```
ENCRYPTION_TYPE_NONE = 0     // No encryption
ENCRYPTION_TYPE_AES = 1      // AES encryption using coin AN
ENCRYPTION_TYPE_LOCKER = 2   // Locker-based encryption
```

### 3.3 Protocol Trailer
All request and response bodies must end with a 2-byte trailer: 0x3e, 0x3e

## 4. Enhanced Data Structures

### 4.1 Enhanced Connection Information Structure
The protocol layer connection information structure includes:
- Echo bytes (2 bytes for client identification)
- Body size and body buffer pointer
- Encryption denomination, serial number, type, and AN (16 bytes)
- **Enhanced nonce management**: Separate request and response nonces
- **request_nonce**: NONCE_SIZE bytes from client request
- **response_nonce**: NONCE_SIZE bytes generated by server
- Output buffer and size for response data
- Command status code
- Challenge hash (16 bytes)
- Command group and command index
- Shard identifier
- Coin identifier
- Execution time tracking

### 4.2 Basic Coin Structure
Each coin reference must contain:
- Denomination (signed 8-bit value)
- Serial number (32-bit unsigned integer)

### 4.3 Enhanced Ticket Entry Structure
Each ticket entry must contain:
- Creation timestamp
- Ticket number (32-bit unsigned integer)
- Array of coins (up to MAX_COINS_PER_TICKET)
- Claims array (TOTAL_RAIDA_SERVERS elements)
- Number of coins (32-bit unsigned integer)
- **Per-slot mutex for fine-grained locking**

## 5. Core Protocol Functions

### 5.1 Enhanced Request Validation

#### 5.1.1 validate_header(buffer, connection_info)
Enhanced header validation must verify:
- Router version (must be 1)
- Split ID (must be 0)
- RAIDA ID (must match configured RAIDA number)
- Shard ID (range 0 to MAX_SHARD)
- Command group (range 0 to MAX_COMMAND_GROUP)
- Command index (range 0 to MAX_COMMAND, must exist in command table)
- Coin ID (must match configured coin ID)
- Encryption type (must be valid type)
- Body size extraction from bytes 22-23
- **Enhanced nonce extraction**: Read full NONCE_SIZE bytes from header bytes 20-31

For AES encryption, extract and validate:
- Encryption denomination from byte 17
- Encryption serial number from bytes 18-21
- Retrieve coin AN from database page
- **Store extracted nonce in request_nonce field**

For Locker encryption, extract:
- Encryption denomination from byte 17
- Retrieve coin AN from index using get_coins_from_index_by_prefix
- **Store extracted nonce in request_nonce field**

#### 5.1.2 validate_decrypt_body(connection_info)
Enhanced body validation must:
- Verify minimum length (18 bytes: 16-byte challenge + 2-byte trailer)
- Validate trailer bytes (0x3e, 0x3e)
- **Use request_nonce for body decryption** if encryption is enabled
- Extract challenge hash (first 16 bytes after decryption)
- Calculate CRC32 of first 12 challenge bytes
- Verify CRC32 matches bytes 12-15 of challenge

### 5.2 Command Processing

#### 5.2.1 run_command(connection_info)
Streamlined command execution process:
- Look up command handler in two-dimensional command table
- Validate command handler exists
- Execute command handler function
- Call prepare_response after command completion

#### 5.2.2 Command Dispatch Table
The system maintains a two-dimensional array of command handlers:
- First dimension: Command group (0-13)
- Second dimension: Command index (0-255)
- Populated entries point to specific command handler functions
- NULL entries indicate invalid commands

### 5.3 Enhanced Response Management

#### 5.3.1 prepare_response(connection_info)
Enhanced response preparation with cryptographic security:

**UDP Response (immediate)**:
- Add 2-byte trailer to output size
- Allocate write buffer for header + body + trailer
- Generate response header
- Copy body content (if present)
- Add trailer bytes
- Send response immediately using sendto
- Clean up resources

**TCP Response (deferred with enhanced security)**:
- **Generate cryptographically secure response nonce** using generate_random_bytes()
- Add 2-byte trailer to output size
- Allocate write buffer for header + body + trailer
- Generate response header with embedded response nonce
- **Encrypt body using unique response_nonce** if encryption is enabled
- Copy encrypted body content
- Add trailer bytes
- Set connection state to STATE_WANT_WRITE
- Signal I/O thread for write processing

#### 5.3.2 get_response_header(buffer, status, command_group, connection_info)
Enhanced response header construction:
- Byte 0: RAIDA number
- Byte 1: Shard ID (always 0)
- Byte 2: Response status code
- Byte 3: Command group
- Bytes 4-5: UDP count (always 0, 1)
- Bytes 6-7: Echo bytes from request
- Byte 8: Reserved (0)
- Bytes 9-11: Output size (24-bit big-endian)
- Bytes 12-15: Execution time (32-bit big-endian microseconds)
- **Bytes 16-27: Response nonce for client decryption (NONCE_SIZE bytes)**
- **Bytes 28-31: Reserved/padding**

### 5.4 Error Handling

#### 5.4.1 send_command_error(error_code, connection_info)
Error response processing:
- Set command status to error code
- Set output size to 0 (no body)
- Free existing output buffer
- Call prepare_response for error transmission

## 6. Enhanced Cryptographic Security

### 6.1 Secure Nonce Management
- **Request Nonce**: Extracted from client request header (bytes 20-31)
- **Response Nonce**: Generated using cryptographically secure random bytes
- **Nonce Size**: NONCE_SIZE (12 bytes) for optimal CTR mode security
- **Nonce Uniqueness**: Each response uses a unique, randomly generated nonce

### 6.2 Enhanced Encryption Protocol
- **Request Decryption**: Uses client-provided request_nonce from header
- **Response Encryption**: Uses server-generated response_nonce
- **Key Management**: AES uses 16-byte AN from coin database or locker index
- **Security Improvement**: Separate nonces prevent nonce reuse vulnerabilities

### 6.3 Cryptographic Operations
- **CTR Mode**: Enhanced CTR mode encryption/decryption with secure nonces
- **Random Generation**: generate_random_bytes() for cryptographically secure nonces
- **CRC32**: Challenge integrity verification
- **MD5**: Various protocol hash operations

## 7. Streamlined Ticket Management System

### 7.1 Optimized Ticket Pool Operations

#### 7.1.1 init_ticket_storage()
Streamlined ticket system initialization:
- Clear all ticket entries in global pool
- **Initialize per-slot mutex for each ticket entry**
- Remove global mutex dependency for operations
- Return error if any mutex initialization fails

#### 7.1.2 get_free_ticket_slot()
Optimized ticket allocation:
- **Use pthread_mutex_trylock() for non-blocking access**
- Search for ticket entry with creation timestamp 0
- Initialize ticket with random number and current timestamp
- Clear coin count and claims array
- **Return locked ticket entry to caller**

#### 7.1.3 get_ticket_entry(ticket_number)
Enhanced ticket retrieval:
- Search pool for ticket with matching ticket number
- **Lock individual ticket entry when found**
- Skip entries with creation timestamp 0
- **Return locked ticket entry if found, NULL otherwise**

#### 7.1.4 unlock_ticket_entry(ticket_entry)
Explicit ticket unlock management:
- **Unlock the specific ticket entry mutex**
- Essential for proper resource management

#### 7.1.5 check_tickets()
Streamlined ticket cleanup:
- Iterate through all ticket entries
- **Lock each ticket individually for expiry check**
- Calculate time difference from creation timestamp
- Free tickets older than TICKET_RELEASE_SECONDS
- **Unlock each ticket immediately after processing**

### 7.2 Performance Optimizations
- **Eliminated Global Mutex**: Per-ticket locking removes bottlenecks
- **Non-Blocking Allocation**: trylock prevents thread starvation
- **Reduced Lock Contention**: Individual ticket operations don't block others
- **Simplified Logic**: Streamlined ticket management code

## 8. Utility Functions

### 8.1 get_body_payload(connection_info)
Returns pointer to request body content after the 16-byte challenge header.

### 8.2 write_stat(connection_info)
Logs statistical information including:
- Timestamp in microseconds
- Client IP address
- Encryption denomination and serial number
- Command group and command index
- Execution time
- Command status

### 8.3 finish_command(connection_info)
Resource cleanup:
- For TCP connections: Log completion status
- For UDP connections: Free connection info structure

## 9. Integration Dependencies

### 9.1 Enhanced Cryptographic Integration
- **generate_random_bytes**: Cryptographically secure random number generation
- **crypt_ctr**: Enhanced CTR mode encryption/decryption with nonce support
- **crc32b**: CRC32 calculation for challenge verification
- **md5**: MD5 hash calculation for various operations

### 9.2 Database Layer Integration
- get_page_by_sn_lock: Retrieve coin data page
- unlock_page: Release page lock
- get_coins_from_index_by_prefix: Retrieve coin from index by partial AN

### 9.3 Network Layer Integration
- arm_socket_for_write: Signal I/O thread for TCP write
- free_ci: Clean up connection information

### 9.4 Utility Integration
- get_sn: Extract serial number from byte array
- Various time and random number functions

## 10. Performance Optimizations

### 10.1 Enhanced Security Performance
- **Secure Random Generation**: Efficient cryptographically secure nonce generation
- **Optimized Encryption**: Separate nonces eliminate nonce management overhead
- **Reduced Complexity**: Streamlined encryption handling

### 10.2 Streamlined Ticket Operations
- **Per-ticket locking eliminates global bottlenecks**
- **Non-blocking ticket allocation improves responsiveness**
- **Individual ticket expiry checking reduces lock contention**
- **Simplified ticket management reduces CPU overhead**

### 10.3 Protocol Efficiency
- **Command Dispatch**: Two-dimensional array provides O(1) command lookup
- **Header Processing**: Streamlined validation with enhanced security
- **Memory Management**: Optimized buffer allocation and cleanup

## 11. Security Enhancements

### 11.1 Cryptographic Improvements
- **Nonce Uniqueness**: Each response uses a unique, secure nonce
- **CTR Mode Security**: Proper nonce handling prevents security vulnerabilities
- **Random Quality**: Cryptographically secure random number generation
- **Key Isolation**: Separate nonces for request and response encryption

### 11.2 Protocol Security
- **Header Authentication**: Enhanced header validation with nonce verification
- **Challenge Verification**: Robust challenge-response authentication
- **Error Handling**: Secure error responses that don't leak information
- **Resource Protection**: Secure memory and resource management


This specification provides complete implementation guidance for the enhanced CloudCoin protocol layer with advanced cryptographic security and streamlined ticket management while remaining language-agnostic and accurately reflecting the security-focused implementation improvements. -->



# Protocol Layer Implementation (protocol)

## Module Purpose
This module implements the core RAIDA X protocol for secure communication between clients and servers. It provides request/response processing, cryptographic operations, header validation, command routing, and ticket management with enhanced security through unique per-message nonces. The system supports multiple encryption modes, fine-grained ticket locking, and comprehensive command dispatch across all functional areas.

## Core Architecture

### Protocol Security Enhancements
**CRITICAL SECURITY IMPROVEMENT:** Implementation of unique, cryptographically secure nonces for each request and response, eliminating nonce reuse vulnerabilities.

#### Enhanced Nonce Management
- **Request Nonces:** 12-byte nonces provided by clients in request headers
- **Response Nonces:** 12-byte nonces generated by server for each response
- **Cryptographic Security:** All nonces generated using secure random sources
- **No Reuse:** Each message uses a unique nonce, preventing replay attacks

### Command Dispatch System
- **Modular Architecture:** Commands organized by functional groups
- **Function Pointer Tables:** Efficient O(1) command resolution
- **Comprehensive Coverage:** Support for all RAIDA operational categories
- **Error Handling:** Graceful handling of invalid or unimplemented commands

## Core Functionality

### 1. Request Processing (`run_command`)
**Parameters:**
- Thread argument pointer (connection information structure)

**Returns:** None

**Purpose:** Main request processing function executed in thread pool context.

**Process:**
1. **Parameter Validation:**
   - Validates connection information structure is not NULL
   - Ensures proper request state and data integrity

2. **Command Resolution:**
   - Extracts command group and command number from request
   - Looks up command handler using two-dimensional function pointer table
   - Validates command exists and is implemented

3. **Command Execution:**
   - Calls appropriate command handler function
   - Passes connection information for request processing
   - Handles command-specific logic and business rules

4. **Response Preparation:**
   - Calls prepare_response to format complete response
   - Handles response encryption and formatting
   - Prepares connection for response transmission

**Dependencies:**
- Command handler functions from various modules
- Response preparation and encryption systems
- Error handling for invalid commands

### 2. Response Preparation (`prepare_response`)
**Parameters:**
- Connection information structure pointer

**Returns:** None

**Purpose:** Prepares complete response with enhanced security through unique response nonces.

**Process:**

#### UDP Response Handling (Connectionless)
1. **Immediate Response Processing:**
   - Adds 2-byte trailer to response size
   - Allocates complete response buffer
   - Generates response header with status information
   - Appends response body if present
   - Adds protocol trailer (0x3e, 0x3e)
   - Sends response immediately using sendto()
   - Logs statistics and cleans up connection

#### TCP Response Handling (Connection-based)
2. **Enhanced Security Response Preparation:**
   - Adds 2-byte trailer to response size
   - Allocates complete response buffer

3. **CRITICAL: Secure Nonce Generation:**
   - Generates cryptographically secure 12-byte response nonce
   - Uses secure random number generation
   - Ensures nonce uniqueness for each response
   - Handles generation failures with appropriate error responses

4. **Response Header Generation:**
   - Calls get_response_header with enhanced nonce handling
   - Includes response nonce in header (NOT the challenge hash)
   - Provides timing and status information

5. **Body Encryption (Enhanced Security):**
   - If response body exists and encryption is enabled:
     - Uses the NEW unique response_nonce for encryption
     - Encrypts using CTR mode with proper nonce
     - Ensures each response has unique encryption parameters
   - Appends encrypted body to response buffer

6. **TCP Connection Preparation:**
   - Adds protocol trailer bytes
   - Sets connection state to write mode
   - Signals main I/O thread for write operation

**Security Enhancement:** Response nonce generation ensures each message has unique encryption parameters, preventing cryptographic attacks based on nonce reuse.

### 3. Enhanced Header Validation (`validate_header`)
**Parameters:**
- Request buffer (unsigned character array)
- Connection information structure pointer

**Returns:** Integer error code (NO_ERROR for success)

**Purpose:** Validates request header with comprehensive security and parameter checking.

**Process:**

#### Basic Protocol Validation
1. **Protocol Version Check:**
   - Validates protocol version field (must be 1)
   - Checks split ID field (must be 0)
   - Verifies RAIDA ID matches server configuration

2. **Command Validation:**
   - Extracts and validates command group (≤ MAX_COMMAND_GROUP)
   - Extracts and validates command number
   - Verifies command handler exists in dispatch table
   - Validates shard ID is within acceptable range

3. **Coin and Size Validation:**
   - Validates coin ID matches server configuration
   - Extracts and validates body size
   - Ensures body size is within security limits

#### Enhanced Encryption Validation
4. **Encryption Type Processing:**
   - Validates encryption type (NONE, AES, or LOCKER)
   - For AES encryption:
     - Extracts encryption coin denomination and serial number
     - Retrieves coin data from database with locking
     - Copies authentication number for encryption operations
   - For LOCKER encryption:
     - Looks up locker by partial authentication number
     - Validates locker exists and is accessible

5. **ENHANCED: Nonce Extraction:**
   - Extracts complete 12-byte nonce from request header
   - Stores nonce for use in body decryption
   - Validates nonce format and structure

**Security Features:**
- Comprehensive input validation prevents protocol attacks
- Database locking ensures consistent coin data access
- Encryption validation prevents unauthorized access attempts

### 4. Enhanced Body Validation (`validate_decrypt_body`)
**Parameters:**
- Connection information structure pointer

**Returns:** Integer error code (NO_ERROR for success)

**Purpose:** Validates and decrypts request body with enhanced nonce security.

**Process:**

#### Basic Body Validation
1. **Size and Format Validation:**
   - Validates minimum body size (16 bytes challenge + 2 bytes trailer)
   - Verifies protocol trailer bytes (0x3e, 0x3e)
   - Ensures body format compliance

#### Enhanced Decryption Process
2. **: Nonce-Based Decryption:**
   - Uses the request_nonce extracted from header for decryption
   - Applies CTR mode decryption with proper nonce handling
   - For AES/LOCKER encryption:
     - Decrypts body using authentication number and request nonce
     - Extracts challenge hash through XOR with authentication number
   - For unencrypted requests:
     - Copies challenge hash directly from body

3. **Integrity Verification:**
   - Calculates CRC32 checksum of challenge data
   - Compares with embedded checksum in request
   - Validates data integrity and authenticity

**Security Enhancement:** Use of proper nonce from header ensures correct decryption and prevents cryptographic attacks.

### 5. Enhanced Response Header Generation (`get_response_header`)
**Parameters:**
- Response buffer pointer (character array)
- Status code (integer)
- Command group (integer)
- Connection information structure pointer

**Returns:** None

**Purpose:** Generates response header with enhanced security through response nonce inclusion.

**Process:**
1. **Header Field Population:**
   - Sets RAIDA server identifier
   - Includes command status and group
   - Adds echo bytes from original request
   - Calculates and includes response body size

2. **Timing Information:**
   - Calculates execution time from start timestamp
   - Includes timing in microseconds for performance monitoring
   - Updates connection structure with execution time

3. **ENHANCED: Response Nonce Inclusion:**
   - **CRITICAL CHANGE:** Includes response_nonce instead of challenge hash
   - Client must use this nonce to decrypt the response body
   - Ensures unique encryption parameters for each response
   - Improves security by eliminating nonce reuse

**Security Improvement:** Response nonce in header enables secure, unique encryption for each message exchange.

## Ticket Management System

### 6. Enhanced Ticket Storage (`init_ticket_storage`)
**Parameters:** None

**Returns:** Integer status code (0 for success, negative for error)

**Purpose:** Initializes ticket memory pool with fine-grained locking for improved concurrency.

**Process:**
1. **Ticket Pool Initialization:**
   - Initializes TICKET_POOL_SIZE ticket entries
   - Sets all creation timestamps to 0 (inactive state)

2. **ENHANCED: Per-Ticket Mutex Initialization:**
   - Creates individual mutex for each ticket slot
   - Enables fine-grained locking for better concurrency
   - Reduces lock contention in multi-threaded scenarios

**Concurrency Improvement:** Per-slot mutexes eliminate global lock contention, improving performance under load.

### 7. Optimized Ticket Management (`get_free_ticket_slot`)
**Parameters:** None

**Returns:** Pointer to ticket entry (NULL if no slots available)

**Purpose:** Allocates ticket slot using non-blocking approach for improved performance.

**Process:**
1. **OPTIMIZED: Non-Blocking Allocation:**
   - Uses pthread_mutex_trylock instead of blocking lock
   - Scans ticket pool for available slots
   - Avoids blocking when tickets are heavily contended

2. **Ticket Initialization:**
   - Sets creation timestamp to current time
   - Generates random ticket identifier
   - Initializes coin array and claim tracking
   - Returns locked ticket for immediate use

**Performance Benefit:** Non-blocking approach prevents thread starvation during high load.

### 8. Thread-Safe Ticket Access (`get_ticket_entry`, `unlock_ticket_entry`)

#### `get_ticket_entry`
**Parameters:**
- Ticket identifier (32-bit unsigned integer)

**Returns:** Pointer to ticket entry (NULL if not found, returned locked)

**Purpose:** Retrieves ticket by identifier with automatic locking.

#### `unlock_ticket_entry`
**Parameters:**
- Ticket entry structure pointer

**Returns:** None

**Purpose:** Releases ticket lock after use.

**Thread Safety Features:**
- Automatic locking ensures thread-safe access
- Proper lock/unlock pairing prevents deadlocks
- Timeout handling prevents resource leaks

### 9. Ticket Cleanup (`check_tickets`)
**Parameters:** None

**Returns:** None

**Purpose:** Removes expired tickets using fine-grained locking.

**Process:**
1. **Per-Ticket Cleanup:**
   - Locks each ticket individually for expiry checking
   - Calculates time since creation
   - Releases expired tickets (> TICKET_RELEASE_SECONDS)
   - Unlocks ticket after processing

**Efficiency:** Fine-grained locking allows concurrent cleanup and allocation operations.

## Command Dispatch System

### 10. Command Handler Table
**Purpose:** Organized function pointer table for efficient command dispatch

#### Command Categories
- **Status (0):** Health checking, version, audit, statistics
- **Auth (1):** Detection, proof-of-ownership operations
- **Healing (2):** Ticket management, coin recovery, repair operations
- **Executive (3):** Administrative coin lifecycle management
- **Key Exchange (4):** Cryptographic key management and exchange
- **Locker (5):** Secure coin storage and trading operations
- **Change (6):** Denomination conversion operations
- **Shard (7):**  migration operations
- **Crossover (8):**  value transfer
- **RPC (9):** Remote procedure calls and utilities
- **Filesystem (10):** Object storage and file management

#### Command Resolution
- **O(1) Lookup:** Direct array access using command group and number
- **Validation:** NULL entries indicate unimplemented commands
- **Error Handling:** Invalid commands return appropriate error codes

## Utility Functions

### 11. Payload Access (`get_body_payload`)
**Parameters:**
- Connection information structure pointer

**Returns:** Pointer to payload data (skipping 16-byte challenge)

**Purpose:** Provides access to actual request payload after protocol overhead.

### 12. Error Response Handling (`send_command_error`)
**Parameters:**
- Error code (integer)
- Connection information structure pointer

**Returns:** None

**Purpose:** Sends standardized error response for protocol or processing failures.

**Process:**
1. Sets appropriate error status code
2. Clears response body (errors have no body)
3. Calls response preparation for error formatting
4. Ensures consistent error response format

### 13. Statistics and Logging (`write_stat`)
**Parameters:**
- Connection information structure pointer

**Returns:** None

**Purpose:** Logs comprehensive request statistics for monitoring and analysis.

**Logged Information:**
- Request timestamp with microsecond precision
- Client IP address for security tracking
- Encryption coin information (denomination/serial number)
- Command group and number for usage analysis
- Execution time for performance monitoring
- Command status for success/failure tracking

## Security Features

### Cryptographic Security
- **Unique Nonces:** Each request/response uses unique nonce for encryption
- **Secure Random Generation:** All nonces generated using cryptographically secure methods
- **CTR Mode Encryption:** Proper counter mode encryption with unique initialization vectors
- **Integrity Verification:** CRC32 checksums validate data integrity

### Nonce Format and Usage

- Each request/response includes a **12-byte (96-bit) nonce** used for AES-CTR encryption.
- **Request Nonce:**
  - Sent by client in bytes 20–31 of the request header.
  - Used to decrypt the request body if encryption is enabled.
- **Response Nonce:**
  - Generated by the server using a cryptographically secure source.
  - Sent in bytes 16–27 of the response header.
  - Used by the client to decrypt the response body.
- **Important:** Nonces must never repeat for a given encryption key.


### Access Control
- **Coin-Based Authentication:** Encryption coins prove ownership for secure operations
- **Locker-Based Authentication:** Locker ownership enables secure collection operations
- **Command Authorization:** Different commands require different authentication levels
- **Input Validation:** All inputs validated before processing

### Protocol Security
- **Version Validation:** Ensures protocol compatibility and prevents downgrade attacks
- **Size Limits:** Prevents resource exhaustion through oversized requests
- **Format Validation:** Strict format checking prevents protocol injection attacks
- **Error Handling:** Secure error responses prevent information leakage

## Dependencies and Integration

### Required Modules
- **Command Implementation Modules:** All cmd_*.c files providing command handlers
- **Database Layer:** Coin data access, page locking, authentication number retrieval
- **Cryptographic System:** CTR mode encryption, secure random generation, CRC calculation
- **Network Layer:** Connection management, cross-thread communication
- **Configuration System:** Server identification, coin validation parameters
- **Logging System:** Statistics recording, error reporting, debug output

### Constants Required
| Name                     | Value     | Description |
|--------------------------|-----------|-------------|
| REQUEST_HEADER_SIZE      | 32 bytes  | Size of the fixed request header |
| RESPONSE_HEADER_SIZE     | 32 bytes  | Size of the fixed response header |
| NONCE_SIZE               | 12 bytes  | Secure random nonce (96 bits) |
| TOTAL_RAIDA_SERVERS      | 25        | Total number of RAIDA nodes |
| TICKET_POOL_SIZE         | 512       | Maximum number of in-memory ticket entries |
| MAX_COINS_PER_TICKET     | 4096      | Maximum coins associated with a single ticket |
| TICKET_RELEASE_SECONDS   | 300       | Expiration time for a ticket in seconds |
| RAIDA_SERVER_RCV_TIMEOUT | 32        | Timeout duration for server response (seconds) |
| MAX_COMMAND_GROUP        | 13        | Highest command group index (Filesystem) |
| MAX_COMMAND              | 255       | Maximum number of commands per group |
| MAX_SHARD                | 3         | Maximum shard ID (e.g., SHARD_NEW) |


### Used By
- **Network Layer:** Request processing, response handling
- **All Command Modules:** Protocol utilities, error handling, response formatting
- **Main Server:** Protocol initialization, ticket management

### Error Codes

| Code Name                  | Meaning |
|---------------------------|---------|
| ERROR_INVALID_COMMAND      | Command not found in dispatch table |
| ERROR_INVALID_ENCRYPTION   | Encryption type not supported or failed lookup |
| ERROR_MEMORY_ALLOC         | Memory allocation failure during response preparation |
| ERROR_INVALID_PACKET_LENGTH| Request body too short |
| ERROR_INVALID_EOF          | Trailer bytes incorrect |
| ERROR_INVALID_CRC          | Challenge data checksum failed |
| NO_ERROR                   | Indicates successful processing |


### Connection States

| State Name        | Description |
|-------------------|-------------|
| STATE_WANT_WRITE  | Response is ready and waiting to be sent |
| STATE_READING     | Reading incoming data from the socket |
| STATE_PROCESSING  | Command being executed in a thread |
| STATE_CLOSED      | Connection closed or finished |


## Performance Characteristics

### Request Processing
- **O(1) Command Dispatch:** Direct function pointer lookup
- **Minimal Copying:** Request data accessed in-place when possible
- **Efficient Encryption:** Hardware-accelerated AES when available
- **Parallel Processing:** Thread pool enables concurrent request handling

### Memory Management
- **Dynamic Allocation:** Response buffers allocated as needed
- **Automatic Cleanup:** Resources freed automatically on completion
- **Pool Management:** Ticket pool minimizes allocation overhead
- **Cache Efficiency:** Hot code paths optimized for CPU cache

### Concurrency
- **Fine-Grained Locking:** Per-ticket mutexes reduce contention
- **Lock-Free Operations:** Non-blocking ticket allocation when possible
- **Thread Safety:** All operations safe for concurrent access
- **Scalability:** Performance scales with number of CPU cores

This protocol layer provides the secure, efficient foundation for all RAIDA network communication, with enhanced security through unique nonce management and optimized performance through fine-grained locking and efficient command dispatch.