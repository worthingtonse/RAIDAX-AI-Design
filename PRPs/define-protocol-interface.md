# Specification:   Protocol Header Interface

## 1. Module Purpose
This specification defines the enhanced public interface for the CloudCoin protocol layer with advanced cryptographic security. It establishes the data structures, constants, enumerations, and function signatures required to implement the RAIDA protocol handling system with secure per-message nonce generation and streamlined ticket management.

## 2. System Constants

### 2.1 Enhanced Protocol Frame Constants
```
REQUEST_HEADER_SIZE = 32        // Fixed request header size in bytes
RESPONSE_HEADER_SIZE = 32       // Fixed response header size in bytes
NONCE_SIZE = 12                 // Standard secure nonce size for CTR mode (96 bits)
TOTAL_RAIDA_SERVERS = 25        // Number of RAIDA servers in network
```

### 2.2 Enhanced Ticket System Constants
```
TICKET_POOL_SIZE = 512          // Maximum concurrent tickets
MAX_COINS_PER_TICKET = 4096     // Maximum coins per ticket
TICKET_RELEASE_SECONDS = 300    // Ticket expiration time
RAIDA_SERVER_RCV_TIMEOUT = 32   // Server response timeout
```

### 2.3 Command System Constants
```
MAX_COMMAND_GROUP = 13          // Maximum command group index
MAX_COMMAND = 255               // Maximum command index
MAX_SHARD = 3                   // Maximum shard index
```

## 3. Core Data Structures

### 3.1 Basic Coin Structure
```
coin_structure:
    denomination: signed_8bit_integer    // Coin denomination (-8 to 6)
    sn: unsigned_32bit_integer          // Serial number
```

### 3.2 Connection State Enumeration
```
connection_state_enum:
    STATE_WANT_READ_HEADER = 0    // Waiting to read request header
    STATE_WANT_READ_BODY = 1      // Waiting to read request body
    STATE_PROCESSING = 2          // Request being processed
    STATE_WANT_WRITE = 3          // Ready to write response
    STATE_DONE = 4                // Connection finished
```

### 3.3 Enhanced Connection Information Structure
The connection information structure must include all network layer fields plus enhanced cryptographic fields:

**Protocol-Specific Fields:**
- Socket address pointer (for UDP connections)
- Socket file descriptor
- Echo bytes (2 unsigned 8-bit integers)
- Body size and body buffer pointer
- Encryption denomination (signed 8-bit integer)
- Encryption serial number (unsigned 32-bit integer)
- Encryption type (integer)
- Encryption AN array (16 bytes)
- **Enhanced nonce management**:
  - **request_nonce**: byte_array[NONCE_SIZE] from client request
  - **response_nonce**: byte_array[NONCE_SIZE] generated by server
- Output size and output buffer pointer
- Command status (unsigned 8-bit integer)
- Challenge hash array (16 bytes)
- Start time structure (platform timestamp)
- Command group (unsigned 8-bit integer)
- Command index (unsigned 8-bit integer)
- Shard ID (unsigned 8-bit integer)
- IP address string (16 characters)
- Execution time (unsigned long integer)
- Coin ID (unsigned 8-bit integer)

**Network I/O Fields:**
- Connection state (from enumeration)
- Read buffer (REQUEST_HEADER_SIZE bytes)
- Bytes to read and bytes read (integers)
- Write buffer pointer
- Bytes to write and bytes written (integers)

### 3.4 Enhanced Ticket Entry Structure
```
ticket_entry_structure:
    created_at: timestamp_type              // Creation time
    ticket: unsigned_32bit_integer          // Ticket number
    coins: array[MAX_COINS_PER_TICKET] of coin_structure
    claims: array[TOTAL_RAIDA_SERVERS] of character
    num_coins: unsigned_32bit_integer       // Number of coins in ticket
    mtx: mutex_type                         // Per-slot mutex for fine-grained locking
```

## 4. Enumeration Definitions

### 4.1 Encryption Types
```
ENCRYPTION_TYPE_NONE = 0      // No encryption
ENCRYPTION_TYPE_AES = 1       // AES encryption using coin AN
ENCRYPTION_TYPE_LOCKER = 2    // Locker-based encryption
```

### 4.2 Command Groups
```
NO_COMMAND_GROUP = 0    // Status operations
AUTH = 1                // Authentication operations
HEALING = 2             // Recovery operations
ADMIN = 3               // Executive functions
KEY_EXCHANGE = 4        // Key management
BANKING = 5             // Banking operations
CHAT = 6                // Communication
BLOCKCHAIN = 7          // Blockchain interface
LOCKER = 8              // Storage operations
CHANGE = 9              // Denomination changes
SHARD = 10              // Shard management
CROSSOVER = 11          // Cross-network operations
RPC = 12                // Remote procedure calls
FILESYSTEM = 13         // File operations
```

### 4.3 Shard Types
```
SHARD_UNKNOWN = 0
SHARD_CLOUDCOIN = 1
SHARD_SUPERCOIN = 2
SHARD_NEW = 3
```

### 4.4 Status Codes
The system defines comprehensive status codes including:

**Success Codes:**
- NO_ERROR = 0
- STATUS_SUCCESS = 250
- STATUS_ALL_PASS = 241
- STATUS_ALL_FAIL = 242
- STATUS_MIXED = 243

**Validation Errors:**
- ERROR_INVALID_CLOUD_ID = 1
- ERROR_INVALID_SPLIT_ID = 2
- ERROR_INVALID_RAIDA_ID = 3
- ERROR_INVALID_SHARD_ID = 4
- ERROR_INVALID_COMMAND_GROUP = 5
- ERROR_INVALID_COMMAND = 6
- ERROR_INVALID_COIN_ID = 7

**Protocol Errors:**
- ERROR_INVALID_PACKET_LENGTH = 16
- ERROR_INVALID_EOF = 33
- ERROR_INVALID_ENCRYPTION = 34
- ERROR_INVALID_CRC = 37

**System Errors:**
- ERROR_MEMORY_ALLOC = 254
- ERROR_INTERNAL = 252
- ERROR_NETWORK = 253

**Ticket System Errors:**
- ERROR_NO_TICKET_SLOT = 42
- ERROR_NO_TICKET_FOUND = 43
- ERROR_TICKET_CLAIMED_ALREADY = 44

## 5. Public Function Interface

### 5.1 Enhanced Request Validation Functions

#### 5.1.1 validate_header(buffer, connection_info)
```
Function: validate_header
Parameters: 
    buffer: pointer to unsigned byte array (header data)
    connection_info: pointer to connection information structure
Returns: integer (status code: NO_ERROR or error code)
Purpose: Validate request header and extract protocol fields including nonce
Enhanced Features: Extracts NONCE_SIZE bytes from header for request_nonce
```

#### 5.1.2 validate_decrypt_body(connection_info)
```
Function: validate_decrypt_body
Parameters: connection_info: pointer to connection information structure
Returns: integer (status code: NO_ERROR or error code)
Purpose: Validate request body, decrypt using request_nonce, verify challenge
Enhanced Features: Uses request_nonce for secure decryption
```

### 5.2 Command Processing Functions

#### 5.2.1 run_command(connection_info)
```
Function: run_command
Parameters: arg: generic pointer (cast to connection_info)
Returns: void
Purpose: Execute command handler and prepare response
Thread Context: Called by worker thread pool
```

#### 5.2.2 Command Handler Function Type
```
command_handler_function_type:
    Parameters: connection_info (pointer to connection information)
    Returns: void
    Purpose: Process specific command and set output
```

### 5.3 Enhanced Response Generation Functions

#### 5.3.1 prepare_response(connection_info)
```
Function: prepare_response
Parameters: connection_info: pointer to connection information structure
Returns: void
Purpose: Create complete response with header and encrypted body
Enhanced Features: 
    - Generates cryptographically secure response_nonce
    - Uses unique nonce for response encryption
    - Includes response_nonce in header for client decryption
```

#### 5.3.2 get_response_header(buffer, status, command_group, connection_info)
```
Function: get_response_header
Parameters:
    buffer: pointer to character array (output buffer)
    status: integer (response status code)
    command_group: integer (command group identifier)
    connection_info: pointer to connection information structure
Returns: void
Purpose: Construct response header with timing and nonce data
Enhanced Features: Embeds response_nonce in header bytes 16-27
```

#### 5.3.3 finish_command(connection_info)
```
Function: finish_command
Parameters: connection_info: pointer to connection information structure
Returns: void
Purpose: Complete command processing and clean up resources
```

### 5.4 Error Handling Functions

#### 5.4.1 send_command_error(error_code, connection_info)
```
Function: send_command_error
Parameters:
    error_code: integer (status code)
    connection_info: pointer to connection information structure
Returns: void
Purpose: Send error response and prepare for connection closure
```

### 5.5 Utility Functions

#### 5.5.1 get_body_payload(connection_info)
```
Function: get_body_payload
Parameters: connection_info: pointer to connection information structure
Returns: pointer to unsigned byte array
Purpose: Get request body content after challenge header
```

#### 5.5.2 write_stat(connection_info)
```
Function: write_stat
Parameters: connection_info: pointer to connection information structure
Returns: void
Purpose: Log statistical information for completed request
```

### 5.6 Enhanced Ticket Management Functions

#### 5.6.1 init_ticket_storage()
```
Function: init_ticket_storage
Parameters: none
Returns: integer (0 = success, negative = error)
Purpose: Initialize ticket pool with per-slot mutexes
Enhanced Features: Streamlined initialization without global mutex dependency
```

#### 5.6.2 check_tickets()
```
Function: check_tickets
Parameters: none
Returns: void
Purpose: Clean up expired tickets using individual slot locking
Enhanced Features: Per-ticket locking for minimal contention
```

#### 5.6.3 get_free_ticket_slot()
```
Function: get_free_ticket_slot
Parameters: none
Returns: pointer to ticket_entry_structure (NULL if no slots available)
Purpose: Allocate and return locked ticket entry
Enhanced Features: Uses non-blocking trylock mechanism, returns locked ticket
```

#### 5.6.4 get_ticket_entry(ticket_number)
```
Function: get_ticket_entry
Parameters: ticket: unsigned_32bit_integer (ticket identifier)
Returns: pointer to ticket_entry_structure (NULL if not found)
Purpose: Retrieve and lock existing ticket entry by ticket number
Enhanced Features: Returns locked ticket entry, caller must unlock
```

#### 5.6.5 unlock_ticket_entry(ticket_entry)
```
Function: unlock_ticket_entry
Parameters: te: pointer to ticket_entry_structure
Returns: void
Purpose: Unlock ticket entry after use
Enhanced Features: Essential for fine-grained locking system
```

## 6. Enhanced Protocol Header Layout

### 6.1 Request Header Fields (32 bytes)
- Byte 0: Router version (must be 1)
- Byte 1: Split ID (must be 0)
- Byte 2: RAIDA ID (must match server configuration)
- Byte 3: Shard ID (0 to MAX_SHARD)
- Byte 4: Command group (0 to MAX_COMMAND_GROUP)
- Byte 5: Command index (0 to MAX_COMMAND)
- Bytes 6-7: Coin ID (16-bit big-endian)
- Bytes 8-15: Reserved
- Byte 16: Encryption type
- Byte 17: Encryption denomination (if encrypted)
- Bytes 18-21: Encryption serial number (if encrypted)
- Bytes 22-23: Body size (16-bit big-endian)
- **Bytes 20-31: Request nonce (NONCE_SIZE = 12 bytes) for CTR mode**
- Bytes 30-31: Echo bytes

### 6.2 Enhanced Response Header Fields (32 bytes)
- Byte 0: RAIDA number
- Byte 1: Shard ID
- Byte 2: Response status
- Byte 3: Command group
- Bytes 4-5: UDP count
- Bytes 6-7: Echo bytes
- Byte 8: Reserved
- Bytes 9-11: Output size (24-bit big-endian)
- Bytes 12-15: Execution time (32-bit big-endian microseconds)
- **Bytes 16-27: Response nonce (NONCE_SIZE = 12 bytes) for client decryption**
- **Bytes 28-31: Reserved/padding**

## 7. Enhanced Security Requirements

### 7.1 Cryptographic Nonce Management
- **Request Nonce**: Extracted from client request header (NONCE_SIZE bytes)
- **Response Nonce**: Generated using cryptographically secure random bytes
- **Nonce Uniqueness**: Each response must use a unique, randomly generated nonce
- **Nonce Size**: NONCE_SIZE (12 bytes) for optimal CTR mode security

### 7.2 Enhanced Encryption Protocol
- **Request Decryption**: Must use client-provided request_nonce from header
- **Response Encryption**: Must use server-generated response_nonce
- **Key Management**: AES uses 16-byte AN from coin database or locker index
- **Security Isolation**: Separate nonces prevent nonce reuse vulnerabilities

### 7.3 Cryptographic Dependencies
Required cryptographic functions:
- **generate_random_bytes**: Cryptographically secure random number generation
- **crypt_ctr**: CTR mode encryption/decryption with nonce support
- **crc32b**: CRC32 calculation for challenge verification
- **md5**: MD5 hash calculation for protocol operations

## 8. Enhanced Thread Safety Requirements

### 8.1 Streamlined Ticket System Synchronization
- **Per-ticket mutex protection** for individual ticket operations
- **Non-blocking ticket allocation** using trylock mechanism
- **Caller-managed unlocking** for precise resource control
- **Individual ticket cleanup** without global locking

### 8.2 Enhanced Security Thread Safety
- **Secure nonce generation** must be thread-safe
- **Connection-specific nonces** eliminate shared state issues
- **Per-connection encryption context** ensures thread isolation

## 9. Memory Management Requirements

### 9.1 Enhanced Allocation Requirements
- Request body buffers: Allocated based on header body_size field
- Response output buffers: Allocated by command handlers
- Write buffers: Allocated during response preparation
- **Secure nonce storage**: NONCE_SIZE bytes per connection for request/response nonces
- Ticket entries: Statically allocated in global pool with individual mutexes

### 9.2 Enhanced Cleanup Requirements
- All dynamically allocated buffers must be freed during connection cleanup
- **Ticket entries must be unlocked after use via unlock_ticket_entry()**
- **Secure nonce data must be properly managed throughout connection lifecycle**
- Response buffers must be freed after transmission completion

## 10. Integration Dependencies

### 10.1 Enhanced Cryptographic Integration
- **generate_random_bytes**: Platform-specific secure random number generation
- **Enhanced crypt_ctr**: CTR mode with proper nonce handling
- **Security Libraries**: Integration with platform cryptographic libraries

### 10.2 Platform Requirements
- **Random Number Generation**: Cryptographically secure random source
- **Memory Security**: Secure memory handling for sensitive nonce data
- **Threading**: Enhanced thread safety for cryptographic operations

## 11. Performance Considerations

### 11.1 Enhanced Security Performance
- **Secure Random Generation**: Efficient cryptographically secure nonce generation
- **Optimized Encryption**: Separate nonces eliminate coordination overhead
- **Reduced Complexity**: Streamlined nonce management

### 11.2 Streamlined Ticket Performance
- **Eliminated Global Mutex**: Per-ticket locking removes bottlenecks
- **Non-blocking Allocation**: trylock prevents thread starvation
- **Reduced Lock Contention**: Individual operations don't block others

This specification provides the complete interface definition needed to implement the enhanced CloudCoin protocol layer with advanced cryptographic security and streamlined ticket management while remaining language-agnostic and accurately reflecting the security-focused implementation improvements.